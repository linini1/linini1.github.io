<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>axi总线-2(AXI-Lite代码学习)</title>
    <link href="/2022/11/18/axi-lite/"/>
    <url>/2022/11/18/axi-lite/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这篇博客对vivado IP 给出的axi-lite 代码进行通读加深对axi总线的理解</p><span id="more"></span><h1 id="AXI-LITE代码导读"><a href="#AXI-LITE代码导读" class="headerlink" title="AXI-LITE代码导读"></a>AXI-LITE代码导读</h1><p>通过学习vivado的axi-lite的ip加深axi-lite的理解</p><h2 id="master部分"><a href="#master部分" class="headerlink" title="master部分"></a>master部分</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">parameter</span>  C_M_START_DATA_VALUE= <span class="hljs-number">32&#x27;hAA000000</span><br><span class="hljs-keyword">parameter</span>  C_M_TARGET_SLAVE_BASE_ADDR= <span class="hljs-number">32&#x27;h40000000</span><br><span class="hljs-keyword">parameter</span> <span class="hljs-keyword">integer</span> C_M_AXI_ADDR_WIDTH= <span class="hljs-number">32</span><br><span class="hljs-keyword">parameter</span> <span class="hljs-keyword">integer</span> C_M_AXI_DATA_WIDTH= <span class="hljs-number">32</span><br><span class="hljs-keyword">parameter</span> <span class="hljs-keyword">integer</span> C_M_TRANSACTIONS_NUM= <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>以上是ip代码提供的参数，分别是初始值，从机的入口地址，以及主机的地址数据位宽（自己初始化时设置的），最后一个是主机进行读写传输的通道数</p><h3 id="端口信号"><a href="#端口信号" class="headerlink" title="端口信号"></a>端口信号</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">input</span>  <span class="hljs-keyword">wire</span>  INIT_AXI_TXN,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span>  ERROR,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>  TXN_DONE,<br></code></pre></td></tr></table></figure><p>以上用来记录一些仿真信息及初始化的，可以略过</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span>  M_AXI_ACLK,<br><span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span>  M_AXI_ARESETN,<br></code></pre></td></tr></table></figure><p>全局信号时钟和复位</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [C_M_AXI_ADDR_WIDTH-<span class="hljs-number">1</span> : <span class="hljs-number">0</span>] M_AXI_AWADDR,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span> : <span class="hljs-number">0</span>] M_AXI_AWPROT,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>  M_AXI_AWVALID,<br><span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span>  M_AXI_AWREADY,<br><br><span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [C_M_AXI_DATA_WIDTH-<span class="hljs-number">1</span> : <span class="hljs-number">0</span>] M_AXI_WDATA,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [C_M_AXI_DATA_WIDTH/<span class="hljs-number">8</span>-<span class="hljs-number">1</span> : <span class="hljs-number">0</span>] M_AXI_WSTRB,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>  M_AXI_WVALID,<br><span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span>  M_AXI_WREADY,<br><br><span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">1</span> : <span class="hljs-number">0</span>] M_AXI_BRESP,<br><span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span>  M_AXI_BVALID,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>  M_AXI_BREADY,<br><br><span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [C_M_AXI_ADDR_WIDTH-<span class="hljs-number">1</span> : <span class="hljs-number">0</span>] M_AXI_ARADDR,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span> : <span class="hljs-number">0</span>] M_AXI_ARPROT,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>  M_AXI_ARVALID,<br><span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span>  M_AXI_ARREADY,<br><br><span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [C_M_AXI_DATA_WIDTH-<span class="hljs-number">1</span> : <span class="hljs-number">0</span>] M_AXI_RDATA,<br><span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> [<span class="hljs-number">1</span> : <span class="hljs-number">0</span>] M_AXI_RRESP,<br><span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span>  M_AXI_RVALID,<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>  M_AXI_RREADY<br></code></pre></td></tr></table></figure><p>以上端口是五个读写通道的端口，具体可以参考之前的博客</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">parameter [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] <br>IDLE = <span class="hljs-number">2</span>&#x27;b00, // This <span class="hljs-keyword">state</span> initiates AXI4Lite transaction <br>INIT_WRITE   = <span class="hljs-number">2</span>&#x27;b01, // This <span class="hljs-keyword">state</span> initializes write transaction,<br>INIT_READ = <span class="hljs-number">2</span>&#x27;b10, // This <span class="hljs-keyword">state</span> initializes read transaction<br>INIT_COMPARE = <span class="hljs-number">2</span>&#x27;b11; // This <span class="hljs-keyword">state</span> issues the status of comparison <br></code></pre></td></tr></table></figure><p>以上是读写通道的状态机定义并初始化</p><h3 id="时序逻辑"><a href="#时序逻辑" class="headerlink" title="时序逻辑"></a>时序逻辑</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> M_AXI_ACLK)      <br>  <span class="hljs-keyword">begin</span>                                                                        <br>    <span class="hljs-comment">// Initiates AXI transaction delay    </span><br>    <span class="hljs-keyword">if</span> (M_AXI_ARESETN == <span class="hljs-number">0</span> )                                                   <br>      <span class="hljs-keyword">begin</span>                                                                    <br>        init_txn_ff &lt;= <span class="hljs-number">1&#x27;b0</span>;                                                   <br>        init_txn_ff2 &lt;= <span class="hljs-number">1&#x27;b0</span>;                                                   <br>      <span class="hljs-keyword">end</span>                                                                               <br>    <span class="hljs-keyword">else</span>                                                                       <br>      <span class="hljs-keyword">begin</span>  <br>        init_txn_ff &lt;= INIT_AXI_TXN;<br>        init_txn_ff2 &lt;= init_txn_ff;                                                                 <br>      <span class="hljs-keyword">end</span>                                                                      <br>  <span class="hljs-keyword">end</span>     <br><br></code></pre></td></tr></table></figure><p>产生初始化信号</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> M_AXI_ACLK)      <br> <span class="hljs-keyword">begin</span>                                                                        <br>   <span class="hljs-keyword">if</span> (M_AXI_ARESETN == <span class="hljs-number">0</span> || init_txn_pulse == <span class="hljs-number">1&#x27;b1</span>)                                                   <br>     <span class="hljs-keyword">begin</span>                                                                    <br>       axi_awvalid &lt;= <span class="hljs-number">1&#x27;b0</span>;                                                   <br>     <span class="hljs-keyword">end</span>                                                                              <br>   <span class="hljs-keyword">else</span>                                                                       <br>     <span class="hljs-keyword">begin</span>                                                                    <br>       <span class="hljs-keyword">if</span> (start_single_write)                                                <br>         <span class="hljs-keyword">begin</span>                                                                <br>           axi_awvalid &lt;= <span class="hljs-number">1&#x27;b1</span>;                                               <br>         <span class="hljs-keyword">end</span>                                                                  <br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (M_AXI_AWREADY &amp;&amp; axi_awvalid)                                 <br>         <span class="hljs-keyword">begin</span>                                                                <br>           axi_awvalid &lt;= <span class="hljs-number">1&#x27;b0</span>;                                               <br>         <span class="hljs-keyword">end</span>                                                                  <br>     <span class="hljs-keyword">end</span>                                                                      <br> <span class="hljs-keyword">end</span>        <br></code></pre></td></tr></table></figure><p>start_single_write有效，开始一次写传输，设置axi_awvalid有效。</p>]]></content>
    
    
    <categories>
      
      <category>知识总结</category>
      
      <category>总线协议</category>
      
      <category>AMBA总线</category>
      
      <category>AXI总线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ic基础</tag>
      
      <tag>代码系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>axi总线-1(手册通读)</title>
    <link href="/2022/11/17/ic-base/"/>
    <url>/2022/11/17/ic-base/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这篇博客记录一下关于AMBA总线里axi总线的学习及控制器代码的撰写，下文中用slave和master代替从机和主机</p><span id="more"></span><h1 id="AXI总线"><a href="#AXI总线" class="headerlink" title="AXI总线"></a>AXI总线</h1><p>AXI总线协议是AMBA总线协议里的一种，支持用于管理器和从属组件之间通信的高性能、高频系统设计，具有一下特点 适用于高带宽和低延迟设计。提供高频操作，无需使用复杂的电桥。该协议满足各种组件的接口要求。适用于具有高初始访问延迟的内存控制器。提供互连架构实施的灵活性。它向后兼容AHB 和APB 接口。包括一个子集AXI-lite(下文也会介绍)</p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>AXI协议定义了5个独立的事务通道，分别为</p><ol><li>读地址AR</li><li>读数据R</li><li>写地址AW</li><li>写数据W</li><li>写响应B<br>其中地址通道承载传输的数据的性质的控制信息。数据在主机和从机之间使用以下读写两种方式传输：</li></ol><img src="/2022/11/17/ic-base/1.png" class title="trans"><img src="/2022/11/17/ic-base/2.png" class title="trans"><p>下面根据官方手册简要记录下读写通道</p><ol><li>读数据通道：<br>携带从Slave 到 maste的读数据和读响应信息包括<strong>数据和指示读事务状态完成的读响应信号</strong></li><li>写数据通道：<br>承载master到slave的写数据，注手册上说明：写数据通道这里<strong>写入数据通道信息始终被视为缓冲的，因此管理器可以执行写入事务而无需下级确认先前的写入事务。</strong>这里我的理解是可以先把数据送进写通道而不用考虑控制信号</li><li>写响应通道：<br>slave使用写响应通道来响应写事务，所有写事务都需要写响应通道上的完成信号，并且仅针对完整事务发出完成信号，而不针对事务中的每个数据传输发出完成信号。意味着如果事务是多数据传输时，只响应本次事务中最后的传输完成的信号</li><li>读写地址通道：<br>分别携带所需的地址及控制信号</li></ol><h2 id="接口信号定义介绍"><a href="#接口信号定义介绍" class="headerlink" title="接口信号定义介绍"></a>接口信号定义介绍</h2><p>主要是valid,ready, 对于地址传输有addr,size, bust，len,对于数据传输主要有data,last, resp。其中我认为注意的是传输方向，根据上方给出的读写传输过程，我们可以看出是从master-&gt;slave 还是slave -&gt; master，其他具体的信号介绍看下面官方定义，</p><h3 id="全局信号"><a href="#全局信号" class="headerlink" title="全局信号"></a>全局信号</h3><p>主要是时钟和复位信号，具体看下面的手册信息</p><img src="/2022/11/17/ic-base/sig-1.png" class title="sig"><h3 id="写地址通道信号"><a href="#写地址通道信号" class="headerlink" title="写地址通道信号"></a>写地址通道信号</h3><img src="/2022/11/17/ic-base/aw-sig.png" class title="sig"><h3 id="写数据通道信号"><a href="#写数据通道信号" class="headerlink" title="写数据通道信号"></a>写数据通道信号</h3><img src="/2022/11/17/ic-base/w-sig.png" class title="sig"><h3 id="写响应通道信号"><a href="#写响应通道信号" class="headerlink" title="写响应通道信号"></a>写响应通道信号</h3><img src="/2022/11/17/ic-base/b-sig.png" class title="sig"><h3 id="读地址通道信号"><a href="#读地址通道信号" class="headerlink" title="读地址通道信号"></a>读地址通道信号</h3><img src="/2022/11/17/ic-base/ar-sig.png" class title="sig"><h3 id="读数据通道信号"><a href="#读数据通道信号" class="headerlink" title="读数据通道信号"></a>读数据通道信号</h3><img src="/2022/11/17/ic-base/r-sig.png" class title="sig"><h2 id="基本读写事务传输机制"><a href="#基本读写事务传输机制" class="headerlink" title="基本读写事务传输机制"></a>基本读写事务传输机制</h2><h3 id="握手机制（最重要）"><a href="#握手机制（最重要）" class="headerlink" title="握手机制（最重要）"></a>握手机制（最重要）</h3><p>握手机制也可以叫valid和ready机制，其中valid信号指示信号何时准备好了可以用，而ready指示什么时候可以接收，只有当valid和ready同时为高才能进行传输，很明显这个是种双向控制，master和slave都能进行传输的控制。<br>对于axi里五个传输通道都有各自的握手信号。<br>这时就产生了个问题，valid和ready信号不同时产生呢？同时拉高时候很容易想到就正常的传输一个周期的数据这就有两种可能，<br>1.先valid拉高，再ready拉高<br>2.先ready拉高，再valid拉高</p><p>对于情况1，先把valid拉高后，表明master已经把信息（数据或控制信号）准备好了，等待slave的接收，当前周期如果没收到ready信号，可能slave在忙，继续等待，直到ready信号拉高，完成传输。<strong>但是这里根据slave发出ready信号的快慢，相当于控制了是在当前周期完成传输还是等一段时间，可以理解为实际的传输速率是由slave控制</strong>，同时这里手册规定了</p><blockquote><p>When VA L I D is asserted, it must remain asserted until the handshake occurs, at a rising clock edge when VA L I D<br>and READY are both asserted.</p></blockquote><p>我个人理解是指valid信号拉高后到第一次ready信号拉高完成握手前都不能变化，但第一次握手后下一数据传输前可以中途拉低valid信号.<br>同时手册规定了master不能通过等待slave的READY信号来确定置起 VALID信号的时机。</p><blockquote><p>A source is not permitted to wait until READY is asserted before asserting VALID.</p></blockquote><p>我理解是这理论上mater和slave都是主动发出要传输的信号，对于master和slave之间没有逻辑关系，不能用与组合逻辑控制valid信号，准备好valid和准备好ready都分别是master和slave主动行为,互相是没有依赖关系的，即不能然如果之间互有依赖则会导致死锁。传输过程可以参考下图</p><img src="/2022/11/17/ic-base/hs-1.png" class title="hs"><p>对于情况2，ready先到了，表明slave已经做好准备接收了，则等到valid拉高后完成握手后则完成传输，对于ready信号，手册规定ready信号可以拉高后在valid还没拉高前拉低，</p><blockquote><p>If READY is asserted, it is permitted to deassert READY before VALID is asserted</p></blockquote><p>传输过程参考下图：</p><img src="/2022/11/17/ic-base/hs-2.png" class title="hs"><h4 id="通道间的握手信息及依赖关系"><a href="#通道间的握手信息及依赖关系" class="headerlink" title="通道间的握手信息及依赖关系"></a>通道间的握手信息及依赖关系</h4><h5 id="基本依赖关系"><a href="#基本依赖关系" class="headerlink" title="基本依赖关系"></a>基本依赖关系</h5><ol><li>VALID 信号不得依赖于接收该信息的READY 信号。</li><li>可以等到它检测到 VALID信号，然后才拉高其相应的 READY 信号。（我理解的是即ready信号可以依赖valid信号）</li></ol><h5 id="读写事务握手信号依赖"><a href="#读写事务握手信号依赖" class="headerlink" title="读写事务握手信号依赖"></a>读写事务握手信号依赖</h5><p>下图表明读写通道间握手信号的依赖关系其中<br>单箭头我理解是其指向的信号可以在箭头起始信号置起之前或之后置起（无依赖关系）<br>双头箭我理解是其指向的信号必须在箭头起始信号置起之后置起（指向信号依赖起始信号）如RVALUD必须等ARVALID和ARREADY信号均拉高后再拉高<br><strong>读事务</strong></p><img src="/2022/11/17/ic-base/ar_hs.png" class title="r-hs"><p><strong>写事务</strong></p><img src="/2022/11/17/ic-base/aw-hs.png" class title="w-hs"><h3 id="突发传输"><a href="#突发传输" class="headerlink" title="突发传输"></a>突发传输</h3>]]></content>
    
    
    <categories>
      
      <category>知识总结</category>
      
      <category>总线协议</category>
      
      <category>AMBA总线</category>
      
      <category>AXI总线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ic基础</tag>
      
      <tag>代码系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言指针学习（入门版）</title>
    <link href="/2022/11/15/pointer/"/>
    <url>/2022/11/15/pointer/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p> C语言指针知识学习。本人菜鸡有讲的不明白或错的请批评指正！</p><span id="more"></span><h3 id="指针定义"><a href="#指针定义" class="headerlink" title="指针定义"></a>指针定义</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">int</span> a=<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> *p          <span class="hljs-comment">//定义分配了空间</span><br>p = &amp;a;         <span class="hljs-comment">//赋值</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p = %d\n&quot;</span>,p);   <span class="hljs-comment">//输出的是a的地址</span><br><span class="hljs-type">int</span> *p = &amp;a;    <span class="hljs-comment">//定义和赋值一起</span><br></code></pre></td></tr></table></figure><p>这里是先定义了一个<strong>整型的指针类型</strong>的变量p,p是变量名，<strong>p的值（或者说叫p存放的内容）是a的地址</strong>,p的大小也是int类型的大小。</p><blockquote><p>对计算机的详细存储过程：</p><ol><li>先给a分配4字节大小，然后把5这个值存进去分配的内存空间里，</li><li>然后给p分配4字节大小的空间，取得a的地址后放入分配给p的地址里,<strong>这里的地址也会转换为二进制存存入按顺序存入分配的四字节</strong></li><li>所以直接打印p，则打印的实际对应的是a的地址，<br><strong>即int*存放的是int数据类型大小的类型的地址</strong></li></ol></blockquote><p>再往下定义一个</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">int</span> **s;<br><span class="hljs-attribute">s</span> = &amp;p;<br></code></pre></td></tr></table></figure><p>根据上面的说明这里的变量是s(变量名)，数据类型为int **, 根据赋值我们可以知道s分配的内存空间里存的值是p的地址</p><blockquote><p>总结一下<br>*<em>s放的是p的地址，</em>s里可以看成放的是p地址空间存放的地址，即a的地址（根据上述的p &#x3D; &amp;a;) 即*p &#x3D; &amp;a;<br>则 *<em>s可以看成</em>（&amp;a),a地址存放的值，即 **s &#x3D; a; </p></blockquote><h3 id="指针操作"><a href="#指针操作" class="headerlink" title="指针操作"></a>指针操作</h3><ol><li>*操作-&gt;取值操作</li><li>&amp;操作-&gt;取地址<br> <em>p–&gt;</em>(p),p的值作为内存地址这里叫a，<em>p就说从a这个地址中取出里面存放的数据<br> *<em>p–&gt;</em>(<em>p)–&gt;</em>(*)(p),先取</em>p的值作为地址b，继续从b接着取一次值就是<blockquote><p><strong>不管什么操作左右两边的数据类型得一致，不然不应该进行操作</strong></p></blockquote></li></ol><p>简单的小例子<br>        <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">char</span> *<span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;hello world&quot;</span>;<br>printf(<span class="hljs-string">&quot;%c\n&quot;</span>,*<span class="hljs-built_in">str</span>);<br></code></pre></td></tr></table></figure></p><blockquote><p><strong>这里需要记住的是<em>操作前面的数据类型对应的是最后取值能够存放的对应内存空间，比如这里是char，所以实际上</em>str的值应该是’h’,而不是”hello world”</strong></p></blockquote><p> <strong>参考文章：</strong><br> <a href="https://zhuanlan.zhihu.com/p/101934152">C语言重点——指针篇（一篇让你完全搞懂指针） - 一直流浪的文章 - 知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>知识总结</category>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言常见库函数实现(1)</title>
    <link href="/2022/11/15/libc/"/>
    <url>/2022/11/15/libc/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文将尝试实现string库里的几个常见的库函数</p><span id="more"></span><h1 id="字符类处理函数-string-h"><a href="#字符类处理函数-string-h" class="headerlink" title="字符类处理函数(string.h)"></a>字符类处理函数(string.h)</h1><h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h3><blockquote><p><strong>手册定义:</strong> size_t strlen(const char *s)<br><strong>描述：</strong>calculate the length of a string pointed to by s,excluding the terminating null byte (‘\0’).<br><strong>返回值：</strong>return the number of bytes in the string pointed to by s.</p></blockquote><p>思路：指针操作让其从字符串起始开始移动到最后的’\0’，同时记数，实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">strlen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *tmp = s;<br><span class="hljs-type">size_t</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(*tmp != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>n++;<br>tmp++;<br>&#125;<br><span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h3><blockquote><p><strong>手册定义:</strong> char *strcpy(char *dest, const char *src)<br><strong>描述:</strong>  copy the string pointed to by src, including the terminating null byte (‘\0’), to the buffer pointed to by dest. the string may not overlap,and the destination string dest must be large enough to receive the copy. <strong>Bewarwe of buffer overruns</strong><br><strong>返回值</strong> return a pointer to dest</p></blockquote><p>分析：复制字符串到新字符串包括空字符，返回值是个指针，且要保证目的字符串内存足够大去接收复制的字符串<br>思路：基于上一个实现的strlen函数的话，很容易想到可以定义一个指针从源字符串首字符开始赋值给新字符串，赋值个数为strlen(dest)+1(要加上空字符)，实现代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">char</span> *strcpy(<span class="hljs-built_in">char</span> *dest, const <span class="hljs-built_in">char</span> *src)&#123;<br>int <span class="hljs-built_in">len</span> = strlen(src);<br><span class="hljs-built_in">char</span> *tmp = dest;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">len</span><span class="hljs-comment">--)&#123;</span><br>tmp[<span class="hljs-built_in">len</span>] = src[<span class="hljs-built_in">len</span>];<br>&#125;<br><span class="hljs-keyword">return</span> dest;<br><br></code></pre></td></tr></table></figure><h3 id="strncpy"><a href="#strncpy" class="headerlink" title="strncpy"></a>strncpy</h3><blockquote><p><strong>手册定义：</strong> char *strncpy(char *dest, const char *src, size_t n)<br><strong>描述：</strong> if there is no null byte among the first n byte of src, the string placed in dest will not be null-terminated,if the length of src less than n, strncpy write the null byte to dest ensure n byte are written.</p></blockquote><p>分析：就是strcpy函数多了给n参数，可以选择复制的最大字节个数（n byte)，根据描述这里可以分为当源字符串小于nbyte或者大于nbyte的情况，小于的时候需要补’\0’，大于的话就直接复制过去nbyte相当于strcpy里确定的strlen值，而且源字符串里如果有空字符也要对应复制，所以可以归并成一种情况，实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">strncpy</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src, <span class="hljs-type">size_t</span> n)</span></span>&#123;<br><span class="hljs-type">size_t</span> k;<br><span class="hljs-type">char</span> *tmp = dest;<br><span class="hljs-keyword">for</span>( k = <span class="hljs-number">0</span>; k&lt;n &amp;&amp; src[k] != <span class="hljs-string">&#x27;\0&#x27;</span>; k++)&#123;<br>tmp[k] = src[k];<br>&#125;<br><span class="hljs-keyword">for</span> (; k &lt; n; k++)&#123;<br>tmp[k] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> dest;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="strcat"><a href="#strcat" class="headerlink" title="strcat"></a>strcat</h3><blockquote><p><strong>手册定义</strong> char *strcat(char *dest, const char *src);<br><strong>描述</strong> appends the src string to the dest string, overwriting the terminating null byte ‘\0’ at the end of dest,and add the null byte.<br><strong>返回值</strong> return a pointer to the resulting string dest</p></blockquote><p>分析：从目的字符串最后开始连接一个字符串，要把目的字符串的空字符覆盖掉，所以应该先找到目的字符串长度，然后再进行拼接，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">strcat</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src)</span></span>&#123;<br><span class="hljs-type">size_t</span> len = <span class="hljs-built_in">strlen</span>(dest);<br><span class="hljs-type">char</span> *tmp = dest+len;<br><span class="hljs-keyword">while</span>(*src != <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>*tmp = *src;<br>tmp++;<br>src++;<br>&#125;<br><span class="hljs-keyword">return</span> dest;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h3><blockquote><p><strong>手册定义</strong> int strcmp(const char* s1, const char* s2);<br><strong>描述</strong> compare the two string s1 and s2, the comparision is done using unsigned characters;<br><strong>返回值</strong> 0 –&gt; s1 &#x3D;&#x3D; s2; negative –&gt; s1 less s2; positive s1 &gt; s2;</p></blockquote><p>分析：就是比较两个字符串，一般常用于判断字符串是否相等，所以思路就可以进行指针操作逐一字符比较注意要进行的是无符号的比较，做减法得出返回值，实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strcmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s1,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s2)</span></span>&#123;<br><span class="hljs-type">int</span> ret = *(<span class="hljs-type">unsigned</span> *)s1 - *(<span class="hljs-type">unsigned</span> *)s2;<br><span class="hljs-keyword">while</span> (!ret &amp;&amp; *s1)&#123;<br>s1++;<br>s2++;<br>ret = *(<span class="hljs-type">unsigned</span> *)s1 - *(<span class="hljs-type">unsigned</span> *)s2;<br>&#125;<br><span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="strncmp"><a href="#strncmp" class="headerlink" title="strncmp"></a>strncmp</h3><blockquote><p><strong>手册定义</strong> int strcmp(const char* s1, const char* s2,size_t n);<br><strong>描述</strong> similiar strcmp,but compare the first n bytes of s1 and s2<br><strong>返回值</strong> 0 –&gt; s1 &#x3D;&#x3D; s2; negative –&gt; s1 less s2; positive s1 &gt; s2;</p></blockquote><p>分析：和strcmp类似，但是因为这里只比较前n位，所以得先分出那个字符串长度长，把长的作为比较基准（相等其实没关系了），实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strncmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s1, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *s2,<span class="hljs-type">size_t</span> n)</span> </span>&#123;<br><span class="hljs-type">int</span> ret = *(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)s1 - *(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)s2;<br><span class="hljs-type">int</span> l =  <span class="hljs-built_in">strlen</span>(s1) - <span class="hljs-built_in">strlen</span>(s2);<br><span class="hljs-keyword">if</span>(l &gt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">while</span>(!ret &amp;&amp; n-- != <span class="hljs-number">0</span> &amp;&amp; *s1)&#123;<br>s1++;<br>s2++;<br>ret = *(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)s1 - *(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)s2;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">while</span>(!ret &amp;&amp; n-- != <span class="hljs-number">0</span> &amp;&amp; *s2)&#123;<br>s1++;<br>s2++;<br>ret = *(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)s1 - *(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)s2;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret &lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h3><blockquote><p><strong>手册定义：</strong> void *(void *s, int c, size_t n );<br><strong>描述：</strong>the function fill the first n bytes of the memory area pointed to by s with the constant byte c<br><strong>返回值：</strong> return a pointer to the memory areas</p></blockquote><p>分析：很好理解根据定义。把一块内存里全部填满指定的值(一般用于开辟内存的初始化)。那就直接进行赋值就行，实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-type">void</span> *s, <span class="hljs-type">int</span> c, <span class="hljs-type">size_t</span> n)</span> </span>&#123;<br><span class="hljs-type">char</span> *tmp = s;<br><span class="hljs-keyword">while</span>(n--)&#123;<br>*tmp = c;<br>tmp++;<br>&#125;<br><span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h3><blockquote><p><strong>手册定义：</strong> void *memcpy(void <em>dest, const void</em>src, size_t n);<br><strong>描述：</strong> the function copy n bytes from memory area src to the memory area dest, the memory must not overlap<br><strong>返回值：</strong> return a pointer to dest</p></blockquote><p>分析：根据描述赋值一个内存空间到另一个内存空间中，本质就是把源空间内存里的存的数据复制过去，那只要取指针去指向目的空间，通过指针赋值把值取到目的空间即可，实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> n)</span></span>&#123;<br><span class="hljs-type">char</span> *tmp = dest;<br><span class="hljs-keyword">while</span>(n--) &#123;<br>*tmp = *(<span class="hljs-type">char</span> *)src;<br>src++;<br>tmp++;<br>&#125;<br><span class="hljs-keyword">return</span> dest;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="memcmp"><a href="#memcmp" class="headerlink" title="memcmp"></a>memcmp</h3><blockquote><p><strong>手册定义：</strong> int memcmp(const void *s1, const void *s2, size_t n);<br><strong>描述：</strong> the function compare the first n byte(each interpreted as unsigned char) of the memory area s1 and s2<br><strong>返回值：</strong>n &#x3D; 0,return zero, s1 less than s2 return negative, s1 match s2 return zero, s1 greater than s2 return positive</p></blockquote><p>分析：根据手册本质是比较内存空间的数据大小，和strcmp类似，但是是不考虑空字符的影响，直接比较nbytes，实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">memcmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *s1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *s2, <span class="hljs-type">size_t</span> n)</span> </span>&#123;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(!ret &amp;&amp; n--) &#123;<br>ret = *(<span class="hljs-type">char</span> *)s1 - *(<span class="hljs-type">char</span> *)s2;<br>s1++;<br>s2++;<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="memmove（本质也是内存复制而不是移动）"><a href="#memmove（本质也是内存复制而不是移动）" class="headerlink" title="memmove（本质也是内存复制而不是移动）"></a>memmove（本质也是内存复制而不是移动）</h3><blockquote><p><strong>手册定义：</strong><br><strong>描述：</strong>the fuction copies n bytes from memory src to memory area dest. the memory areas may overlap<br><strong>返回值：</strong>return a pointer to dest</p></blockquote><p>分析：和memcpy类似，但是这里强调源内存空间和目的内存空间是可以重叠的！在不重叠的情况下其实和memcpy一样，但是在重叠的情况下有可能出现越界，所以应该分两种情况，一种源内存空间地址比目的内存空间地址高，则顺序复制，反之逆序复制,这里要注意代码实现是是一位一位复制而调用时可能不是char型的内存空间.具体代码实现如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">void</span> *memmove(<span class="hljs-type">void</span> *dest, const <span class="hljs-type">void</span> *src, size_t n) &#123;<br><span class="hljs-keyword">if</span>(dest &lt; src) &#123;<br><span class="hljs-type">char</span> *p = (<span class="hljs-type">char</span> *)dest;<br><span class="hljs-type">char</span> *q = (<span class="hljs-type">char</span> *)src;<br><span class="hljs-keyword">while</span>(n<span class="hljs-comment">--)&#123;</span><br>*p++ = *q++;<br><br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">char</span> *p = (<span class="hljs-type">char</span> *)dest+n;<br><span class="hljs-type">char</span> *q = (<span class="hljs-type">char</span> *)src+n;<br><span class="hljs-keyword">while</span>(n<span class="hljs-comment">--) &#123;</span><br>*<span class="hljs-comment">--p = *--q;</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dest;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="以上所有实现代码仅进行了简单的测试，仅供参考，欢迎大佬们指正！"><a href="#以上所有实现代码仅进行了简单的测试，仅供参考，欢迎大佬们指正！" class="headerlink" title="以上所有实现代码仅进行了简单的测试，仅供参考，欢迎大佬们指正！"></a><strong>以上所有实现代码仅进行了简单的测试，仅供参考，欢迎大佬们指正！</strong></h4>]]></content>
    
    
    <categories>
      
      <category>知识总结</category>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码系列</tag>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PA2笔记</title>
    <link href="/2022/11/13/pa2/"/>
    <url>/2022/11/13/pa2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>PA2学习笔记</p><span id="more"></span><h1 id="PA2-简单复杂的机器-amp-RTFM"><a href="#PA2-简单复杂的机器-amp-RTFM" class="headerlink" title="PA2-简单复杂的机器&amp;RTFM"></a>PA2-简单复杂的机器&amp;RTFM</h1><h2 id="pa2-1-不停的计算机"><a href="#pa2-1-不停的计算机" class="headerlink" title="pa2.1-不停的计算机"></a>pa2.1-不停的计算机</h2><p>再次强化计算机是个状态机   取指-&gt;执行指令-&gt;更新pc</p><h3 id="Q1-理解YEMU如何执行"><a href="#Q1-理解YEMU如何执行" class="headerlink" title="Q1. 理解YEMU如何执行"></a>Q1. 理解YEMU如何执行</h3><ol><li><p>位域结构</p><p> struct {<br>  uint8_t rs : 2, rt : 2, op : 4;<br> } rtype;</p></li></ol><p>所谓“位域”是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 YUMU这里的把rtype的一字节分为多个位域，可以单独访问如rtype.rs表示该字节的低两位<br>有两个注意的点<br><strong>1. 一个位域必须存储在同一个字节中，不能跨两个字节。如一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。</strong><br><strong>2. 由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进位</strong></p><pre><code class="hljs">    struct   bs      &#123;      unsigned   a:4      unsigned   :0   /*空域*/      unsigned   b:4   /*从下一单元开始存放*/      unsigned   c:4      &#125; </code></pre><ol start="2"><li>联合体</li></ol><p>联合成员则共享同一个内存位置。也就是说，联合中的所有成员都是从相同的内存地址开始,实际大小是最大数据类型的倍数;</p><pre><code class="hljs">union Data &#123;int i; double x;string str;&#125;</code></pre><p>所以YEMU是每执行一条指令，先定义了一条指令的联合体分配内存，然后从对应的pc内存里取出指令，根据该条指令的类型的前四位进行指令类型译码，然后根据对应类型的执行，然后使pc指向下一条指令。其中DECODE_R&#x2F;DECODE_M是对于寄存器和访存的宏函数，用于寄存器和内存的读.</p><h3 id="Q2-实现指令"><a href="#Q2-实现指令" class="headerlink" title="Q2. 实现指令"></a>Q2. 实现指令</h3><h4 id="API了解（RISCV64"><a href="#API了解（RISCV64" class="headerlink" title="API了解（RISCV64)"></a>API了解（RISCV64)</h4><ol><li>word_t -&gt; uint64_t</li><li>sword_t-&gt; int64_t</li><li>char *FMT_WORD -&gt; %0x%016lx”</li><li>word_t RESET_VECTOR -&gt; pc初始</li><li>CPU_state{wort_t pc} -&gt;已经定义一个cpu</li><li>ISADecodeInfo-&gt;isa译码结构体</li><li>Decode 译码信息 pc , dnpc, snpc , ISADecode, </li><li>int isa_mmu_check(vaddr_t vaddr, int len, int type); 检查当前系统状态下对内存区间为[vaddr, vaddr + len), 类型为type的访问是否需要经过地址转换. </li><li>paddr_t isa_mmu_translate(vaddr_t vaddr, int len, int type); 对内存区间为[vaddr, vaddr + len), 类型为type的内存访问进行地址转换.</li><li>vaddr_t isa_raise_intr(word_t NO, vaddr_t epc); 抛出一个号码为NO的异常, 其中epc为触发异常的指令PC, 返回异常处理的出口地址.</li><li>word_t isa_query_intr(); 查询当前是否有未处理的中断, 若有则返回中断号码, 否则返回INTR_EMPTY</li></ol><h4 id="一些宏函数"><a href="#一些宏函数" class="headerlink" title="一些宏函数"></a>一些宏函数</h4><ol><li>concct -&gt; 连接两个参数 如 concat(x,y) &#x3D;&#x3D; xy;</li><li>INSTPAT -&gt; </li><li>INSTPAT_INST -&gt;获得指令</li><li>INSTPAT_MATCH指匹配</li><li>decode_operand-&gt;译码</li></ol><h4 id="nemu一条指令的执行"><a href="#nemu一条指令的执行" class="headerlink" title="nemu一条指令的执行"></a>nemu一条指令的执行</h4><ol><li>取指 <ol><li>入口：exec_once()-&gt;isa_exec_once(Decode *s)</li><li>操作：inst_fetch(vaddr_t pc,int len)-&gt;vaddr_ifetch(addr,len)-&gt;paddr_read()-&gt;pmem_read()-&gt;host_read();</li><li>s-&gt;snpc +&#x3D; 4;</li></ol></li><li>译码<ol><li>入口：decode_exec(s);</li><li>操作：调用宏函数模式匹配</li></ol></li><li>执行<ol><li>译码后的执行函数进行指令执行</li></ol></li><li>更新pc<ol><li>s-&gt;pc &#x3D; s-&gt;dnpc;</li><li>s-&gt;dnpc(动态) s-&gt;snpc(静态)</li></ol></li></ol><h4 id="实现指令"><a href="#实现指令" class="headerlink" title="实现指令"></a>实现指令</h4><ol><li>入口：inst.c</li><li>宏R()寄存器，Mr,Mw,访存 ，src1R()取寄存器值一根据指令集设计，BITS()-&gt;[n:m], SEXT()-&gt;有符号扩展，</li><li>值得注意的是J型指令的立即数，因为要扩展所以可以先分别把分开的位先扩展移位后进行按位或运算，有符号比较的时候可以先把变量强制进行有符号转换，跳转指令是动态的所以注意要变得pc应该是什么。</li></ol><h2 id="pa2-2-运行时环境-amp-基础设施"><a href="#pa2-2-运行时环境-amp-基础设施" class="headerlink" title="pa2.2-运行时环境&amp;基础设施"></a>pa2.2-运行时环境&amp;基础设施</h2><h3 id="运行时环境AM"><a href="#运行时环境AM" class="headerlink" title="运行时环境AM"></a>运行时环境AM</h3><h4 id="最简单的运行时环境"><a href="#最简单的运行时环境" class="headerlink" title="最简单的运行时环境"></a>最简单的运行时环境</h4><p>有内存, 有结束运行的方式, 加上实现正确的指令。nemu里pmem物理内存， 结束方式 nemu_trap-&gt;NEMUTRAP-&gt;改变nemu_state使其停下来,isa;</p><h4 id="将运行时环境封装成库函数"><a href="#将运行时环境封装成库函数" class="headerlink" title="将运行时环境封装成库函数"></a>将运行时环境封装成库函数</h4><p>行时环境的一种普遍的存在方式: 库. 通过库, 运行程序所需要的公共要素被抽象成API, 不同的架构只需要实现这些API。</p><h4 id="AM入门"><a href="#AM入门" class="headerlink" title="AM入门"></a>AM入门</h4><pre><code class="hljs">AM = TRM + IOE + CTE + VME + MPE</code></pre><ol><li><p><strong>TRM</strong><br>putch()&#x2F;&#x2F;输出<br>halt()&#x2F;&#x2F;结束-&gt; nemu_trap()-&gt;asm volatike(内联汇编)-&gt;ebreak;<br>_trm_init()&#x2F;&#x2F;初始化<br>Area heap;&#x2F;&#x2F;堆区</p></li><li><p><strong>Q1.通过批处理模式运行NEMU</strong><br>肯定是有个开关的-&gt;如果是通过参数控制肯定有留下读取参数接口-&gt;init_monitor()-&gt;parse_args()-&gt;batch;<br>所以找到对应的编译script-&gt;nemu-&gt;native.mk-&gt;运行参数要加b</p></li><li><p><strong>Q2.常用的C库函数</strong></p><a href="/2022/11/15/libc/" title="C语言库函数实现(1)">C语言库函数实现(1)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>项目系列</category>
      
      <category>ysyx</category>
      
      <category>PA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ysyx</tag>
      
      <tag>pa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown简单语法</title>
    <link href="/2022/11/13/hexo/"/>
    <url>/2022/11/13/hexo/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>简单记录一下markdown语法的一些基本用法</p><span id="more"></span><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p> Markdown 语法的目标是：成为一种适用于网络的书写语言。 因此，Markdown是兼容Html，HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。写一个Markdown文档，可以将直接使用Markdown语法和Html的标签混合进行使用，因为最后都会转换成Html，但要注意的是，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。</p><h2 id="常用基本语法"><a href="#常用基本语法" class="headerlink" title="常用基本语法"></a>常用基本语法</h2><p> 只总结了一些觉得自己常用的上的，不考虑美观</p><pre><code class="hljs">1.标题：常用类ATX形式行首插入1到6个#对应与1到6阶标题，注#后面要有一个空格  2.字体：Markdown 使用星号（*）和底线（_）作为标记强调字词的符号，你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。      3.分割线：可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。     4.引用： 在引用的文字前加 &gt; 即可。5.列表： Markdown 支持有序列表和无序列表。无序列表使用星号、加号或是减号作为列表标记。有序列表则使用数字接着一个英文句点作为标记。列表可以嵌套，上一级和下一级之间敲三个空格即可6.代码：Markdown中加入代码块有两种方式： 第一种，只要简单地缩进 4 个空格或是 1 个制表符就可以，第二种单行代码：代码之间分别用一个反引号包起来即可；</code></pre><h3 id="效果例子"><a href="#效果例子" class="headerlink" title="效果例子"></a>效果例子</h3><ol><li><p>###空格head</p><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3></li><li><p><strong>粗体</strong>（字两边各两个*）</p></li><li><p>三个星</p><hr></li><li><p>引用，开头有个&gt;符号</p><blockquote><p>引用</p></blockquote></li><li><p>列表(无序)</p><ul><li>一 - 二</li></ul></li><li><p>代码块<br><code>#include ....</code></p></li></ol><h2 id="hexo常见命令"><a href="#hexo常见命令" class="headerlink" title="hexo常见命令"></a>hexo常见命令</h2><pre><code class="hljs">hexo g  //产生htmlhexo c  //清除hexo s  //本地部署hexo d  //部署hexo n &lt;title&gt; //创建新文章</code></pre><h3 id="文章内常用表情"><a href="#文章内常用表情" class="headerlink" title="文章内常用表情"></a>文章内常用表情</h3><pre><code class="hljs">categories：- 类别名字tag:标签名字（可多个）date:日期时间title:标题</code></pre>]]></content>
    
    
    <categories>
      
      <category>知识总结</category>
      
      <category>markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客开启</title>
    <link href="/2022/07/25/post/"/>
    <url>/2022/07/25/post/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>好记性不如烂笔头，记录下来自己的学习过程和一些生活趣事！</p><span id="more"></span><h1 id="第一篇博客发个疯"><a href="#第一篇博客发个疯" class="headerlink" title="第一篇博客发个疯"></a>第一篇博客发个疯</h1><p>每天都要记录下，算是监督自己把</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>废话</tag>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
