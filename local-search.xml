<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>博客音乐播放器配置</title>
    <link href="/2022/11/15/blog-music/"/>
    <url>/2022/11/15/blog-music/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p> 整个音乐播放器使博客炫酷点！</p><span id="more"></span>        <div id="aplayer-JFviRniA" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"></div>  <script>  var options = {"narrow":true,"autoplay":true,"showlrc":3,"mode":"random","mutex":true,"theme":"#e6d0b2","preload":"metadata","listmaxheight":"500px","music":[{"title":"阳光宅男","author":"周杰伦","url":"/2022/11/15/blog-music/阳光宅男-周杰伦.mp3","pic":"/2022/11/15/blog-music/3.jpg","lrc":"阳光宅男.lrc"},{"title":"爷爷泡的茶","author":"周杰伦","url":"/2022/11/15/blog-music/爷爷泡的茶-周杰伦.mp3","pic":"/2022/11/15/blog-music/3.jpg","lrc":"爷爷泡的茶.lrc"}]};  options.element = document.getElementById("aplayer-JFviRniA");  var ap = new APlayer(options);    window.aplayers || (window.aplayers = []);  window.aplayers.push(ap);  </script>]]></content>
    
    
    <categories>
      
      <category>博客配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2022/11/15/test/"/>
    <url>/2022/11/15/test/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言指针学习（入门版）</title>
    <link href="/2022/11/15/pointer/"/>
    <url>/2022/11/15/pointer/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p> C语言指针知识学习。本人菜鸡有讲的不明白或错的请批评指正！</p><span id="more"></span><h3 id="指针定义"><a href="#指针定义" class="headerlink" title="指针定义"></a>指针定义</h3><pre><code class="hljs">int a=5;int *p          //定义分配了空间p = &amp;a;         //赋值printf(&quot;p = %d\n&quot;,p);   //输出的是a的地址《==》int *p = &amp;a;    //定义和赋值一起</code></pre><p>这里是先定义了一个<strong>整型的指针类型</strong>的变量p,p是变量名，<strong>p的值（或者说叫p存放的内容）是a的地址</strong>,p的大小也是int类型的大小。</p><blockquote><p>对计算机的详细存储过程：</p><ol><li>先给a分配4字节大小，然后把5这个值存进去分配的内存空间里，</li><li>然后给p分配4字节大小的空间，取得a的地址后放入分配给p的地址里,<strong>这里的地址也会转换为二进制存存入按顺序存入分配的四字节</strong></li><li>所以直接打印p，则打印的实际对应的是a的地址，<br><strong>即int*存放的是int类型的地址</strong></li></ol></blockquote><p>再往下定义一个</p><pre><code class="hljs">int **s;s = &amp;p;</code></pre><blockquote><p>根据上面的说明这里的变量是s(变量名)，数据类型为int **, 根据赋值我们可以知道s分配的内存空间里存的值是p的地址<br>总结一下<br>*<em>s放的是p的地址，</em>s里可以看成放的是p地址空间存放的地址，即a的地址（根据上述的p &#x3D; &amp;a;) 即*p &#x3D; &amp;a;<br>则 *<em>s可以看成</em>（&amp;a),a地址存放的值，即 **s &#x3D; a; </p></blockquote><p> <strong>参考文章：</strong><br> <a href="https://zhuanlan.zhihu.com/p/101934152">C语言重点——指针篇（一篇让你完全搞懂指针） - 一直流浪的文章 - 知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言常见库函数实现</title>
    <link href="/2022/11/15/libc/"/>
    <url>/2022/11/15/libc/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文将尝试实现几个基本的C语言库函数</p><span id="more"></span><h1 id="字符类处理函数"><a href="#字符类处理函数" class="headerlink" title="字符类处理函数"></a>字符类处理函数</h1><h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h3><blockquote><p><strong>手册定义:</strong> size_t strlen(const char *s)<br><strong>描述：</strong>calculate the length of a string pointed to by s,excluding the terminating null byte (‘\0’).<br><strong>返回值：</strong>return the number of bytes in the string pointed to by s.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>代码系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PA2笔记</title>
    <link href="/2022/11/13/pa2/"/>
    <url>/2022/11/13/pa2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>PA2学习笔记</p><span id="more"></span><h1 id="PA2-简单复杂的机器-amp-RTFM"><a href="#PA2-简单复杂的机器-amp-RTFM" class="headerlink" title="PA2-简单复杂的机器&amp;RTFM"></a>PA2-简单复杂的机器&amp;RTFM</h1><h2 id="pa2-1-不停的计算机"><a href="#pa2-1-不停的计算机" class="headerlink" title="pa2.1-不停的计算机"></a>pa2.1-不停的计算机</h2><p>再次强化计算机是个状态机   取指-&gt;执行指令-&gt;更新pc</p><h3 id="Q1-理解YEMU如何执行"><a href="#Q1-理解YEMU如何执行" class="headerlink" title="Q1. 理解YEMU如何执行"></a>Q1. 理解YEMU如何执行</h3><ol><li><p>位域结构</p><p> struct {<br>  uint8_t rs : 2, rt : 2, op : 4;<br> } rtype;</p></li></ol><p>所谓“位域”是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 YUMU这里的把rtype的一字节分为多个位域，可以单独访问如rtype.rs表示该字节的低两位<br>有两个注意的点<br><strong>1. 一个位域必须存储在同一个字节中，不能跨两个字节。如一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。</strong><br><strong>2. 由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进位</strong></p><pre><code class="hljs">    struct   bs      &#123;      unsigned   a:4      unsigned   :0   /*空域*/      unsigned   b:4   /*从下一单元开始存放*/      unsigned   c:4      &#125; </code></pre><ol start="2"><li>联合体</li></ol><p>联合成员则共享同一个内存位置。也就是说，联合中的所有成员都是从相同的内存地址开始,实际大小是最大数据类型的倍数;</p><pre><code class="hljs">union Data &#123;int i; double x;string str;&#125;</code></pre><p><img src="/.com//img/1114/union.png"></p><p>所以YEMU是每执行一条指令，先定义了一条指令的联合体分配内存，然后从对应的pc内存里取出指令，根据该条指令的类型的前四位进行指令类型译码，然后根据对应类型的执行，然后使pc指向下一条指令。其中DECODE_R&#x2F;DECODE_M是对于寄存器和访存的宏函数，用于寄存器和内存的读.</p><h3 id="Q2-实现指令"><a href="#Q2-实现指令" class="headerlink" title="Q2. 实现指令"></a>Q2. 实现指令</h3><h4 id="API了解（RISCV64"><a href="#API了解（RISCV64" class="headerlink" title="API了解（RISCV64)"></a>API了解（RISCV64)</h4><ol><li>word_t -&gt; uint64_t</li><li>sword_t-&gt; int64_t</li><li>char *FMT_WORD -&gt; %0x%016lx”</li><li>word_t RESET_VECTOR -&gt; pc初始</li><li>CPU_state{wort_t pc} -&gt;已经定义一个cpu</li><li>ISADecodeInfo-&gt;isa译码结构体</li><li>Decode 译码信息 pc , dnpc, snpc , ISADecode, </li><li>int isa_mmu_check(vaddr_t vaddr, int len, int type); 检查当前系统状态下对内存区间为[vaddr, vaddr + len), 类型为type的访问是否需要经过地址转换. </li><li>paddr_t isa_mmu_translate(vaddr_t vaddr, int len, int type); 对内存区间为[vaddr, vaddr + len), 类型为type的内存访问进行地址转换.</li><li>vaddr_t isa_raise_intr(word_t NO, vaddr_t epc); 抛出一个号码为NO的异常, 其中epc为触发异常的指令PC, 返回异常处理的出口地址.</li><li>word_t isa_query_intr(); 查询当前是否有未处理的中断, 若有则返回中断号码, 否则返回INTR_EMPTY</li></ol><h4 id="一些宏函数"><a href="#一些宏函数" class="headerlink" title="一些宏函数"></a>一些宏函数</h4><ol><li>concct -&gt; 连接两个参数 如 concat(x,y) &#x3D;&#x3D; xy;</li><li>INSTPAT -&gt; </li><li>INSTPAT_INST -&gt;获得指令</li><li>INSTPAT_MATCH指匹配</li><li>decode_operand-&gt;译码</li></ol><h4 id="nemu一条指令的执行"><a href="#nemu一条指令的执行" class="headerlink" title="nemu一条指令的执行"></a>nemu一条指令的执行</h4><ol><li>取指 <ol><li>入口：exec_once()-&gt;isa_exec_once(Decode *s)</li><li>操作：inst_fetch(vaddr_t pc,int len)-&gt;vaddr_ifetch(addr,len)-&gt;paddr_read()-&gt;pmem_read()-&gt;host_read();</li><li>s-&gt;snpc +&#x3D; 4;</li></ol></li><li>译码<ol><li>入口：decode_exec(s);</li><li>操作：调用宏函数模式匹配</li></ol></li><li>执行<ol><li>译码后的执行函数进行指令执行</li></ol></li><li>更新pc<ol><li>s-&gt;pc &#x3D; s-&gt;dnpc;</li><li>s-&gt;dnpc(动态) s-&gt;snpc(静态)</li></ol></li></ol><h4 id="实现指令"><a href="#实现指令" class="headerlink" title="实现指令"></a>实现指令</h4><ol><li>入口：inst.c</li><li>宏R()寄存器，Mr,Mw,访存 ，src1R()取寄存器值一根据指令集设计，BITS()-&gt;[n:m], SEXT()-&gt;有符号扩展，</li><li>值得注意的是J型指令的立即数，因为要扩展所以可以先分别把分开的位先扩展移位后进行按位或运算，有符号比较的时候可以先把变量强制进行有符号转换，跳转指令是动态的所以注意要变得pc应该是什么。</li></ol><h2 id="pa2-2-运行时环境-amp-基础设施"><a href="#pa2-2-运行时环境-amp-基础设施" class="headerlink" title="pa2.2-运行时环境&amp;基础设施"></a>pa2.2-运行时环境&amp;基础设施</h2><h3 id="运行时环境AM"><a href="#运行时环境AM" class="headerlink" title="运行时环境AM"></a>运行时环境AM</h3><h4 id="最简单的运行时环境"><a href="#最简单的运行时环境" class="headerlink" title="最简单的运行时环境"></a>最简单的运行时环境</h4><p>有内存, 有结束运行的方式, 加上实现正确的指令。nemu里pmem物理内存， 结束方式 nemu_trap-&gt;NEMUTRAP-&gt;改变nemu_state使其停下来,isa;</p><h4 id="将运行时环境封装成库函数"><a href="#将运行时环境封装成库函数" class="headerlink" title="将运行时环境封装成库函数"></a>将运行时环境封装成库函数</h4><p>行时环境的一种普遍的存在方式: 库. 通过库, 运行程序所需要的公共要素被抽象成API, 不同的架构只需要实现这些API。</p><h4 id="AM入门"><a href="#AM入门" class="headerlink" title="AM入门"></a>AM入门</h4><pre><code class="hljs">AM = TRM + IOE + CTE + VME + MPE</code></pre><ol><li><p><strong>TRM</strong><br>putch()&#x2F;&#x2F;输出<br>halt()&#x2F;&#x2F;结束-&gt; nemu_trap()-&gt;asm volatike(内联汇编)-&gt;ebreak;<br>_trm_init()&#x2F;&#x2F;初始化<br>Area heap;&#x2F;&#x2F;堆区</p></li><li><p><strong>Q.通过批处理模式运行NEMU</strong><br>肯定是有个开关的-&gt;如果是通过参数控制肯定有留下读取参数接口-&gt;init_monitor()-&gt;parse_args()-&gt;batch;<br>所以找到对应的编译script-&gt;nemu-&gt;native.mk-&gt;运行参数要加b</p></li><li><p><strong>常用的C库函数</strong><br>见C语言基础知识目录</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>ysyx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ysyx</tag>
      
      <tag>pa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客部署&amp;markdown简单语法</title>
    <link href="/2022/11/13/hexo/"/>
    <url>/2022/11/13/hexo/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p> Markdown 语法的目标是：成为一种适用于网络的书写语言。 因此，Markdown是兼容Html，HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。写一个Markdown文档，可以将直接使用Markdown语法和Html的标签混合进行使用，因为最后都会转换成Html，但要注意的是，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。</p><h2 id="常用基本语法"><a href="#常用基本语法" class="headerlink" title="常用基本语法"></a>常用基本语法</h2><p> 只总结了一些觉得自己常用的上的，不考虑美观</p><pre><code class="hljs">1.标题：常用类ATX形式行首插入1到6个#对应与1到6阶标题，注#后面要有一个空格  2.字体：Markdown 使用星号（*）和底线（_）作为标记强调字词的符号，你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。      3.分割线：可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。     4.引用： 在引用的文字前加 &gt; 即可。5.列表： Markdown 支持有序列表和无序列表。无序列表使用星号、加号或是减号作为列表标记。有序列表则使用数字接着一个英文句点作为标记。列表可以嵌套，上一级和下一级之间敲三个空格即可6.代码：Markdown中加入代码块有两种方式： 第一种，只要简单地缩进 4 个空格或是 1 个制表符就可以，第二种单行代码：代码之间分别用一个反引号包起来即可；</code></pre><h3 id="效果例子"><a href="#效果例子" class="headerlink" title="效果例子"></a>效果例子</h3><ol><li><p>###空格head</p><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3></li><li><p><strong>粗体</strong>（字两边各两个*）</p></li><li><p>三个星</p><hr></li><li><p>引用，开头有个&gt;符号</p><blockquote><p>引用</p></blockquote></li><li><p>列表(无序)</p><ul><li>一 - 二</li></ul></li><li><p>代码块<br><code>#include ....</code></p></li></ol><h2 id="hexo常见命令"><a href="#hexo常见命令" class="headerlink" title="hexo常见命令"></a>hexo常见命令</h2><pre><code class="hljs">hexo g  //产生htmlhexo c  //清除hexo s  //本地部署hexo d  //部署hexo n &lt;title&gt; //创建新文章</code></pre><h3 id="文章内常用表情"><a href="#文章内常用表情" class="headerlink" title="文章内常用表情"></a>文章内常用表情</h3><pre><code class="hljs">categories：- 类别名字tag:标签名字（可多个）date:日期时间title:标题</code></pre>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>axi总线学习笔记（二）axi总线读RTL实现</title>
    <link href="/2022/08/28/axi2/"/>
    <url>/2022/08/28/axi2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><pre><code class="hljs">本篇文章将根据”一生一芯“项目的要求一步一步实现AXI读写过程的RTL（无突发传输的），并进行测试。</code></pre><span id="more"></span><h1 id="实现总线读写"><a href="#实现总线读写" class="headerlink" title="实现总线读写"></a><b>实现总线读写</b></h1><h2 id="实现axi-ctrl的总线读写"><a href="#实现axi-ctrl的总线读写" class="headerlink" title="实现axi_ctrl的总线读写"></a><b>实现axi_ctrl的总线读写</b></h2><ul><li><h3 id="输入输出信号"><a href="#输入输出信号" class="headerlink" title=" 输入输出信号"></a><b> 输入输出信号</b></h3><p>  根据上章文档里给出的通道信号我们可以将其确定下来，部分信号如下图，其中我把信号来源和输入输出分开了，其中前缀m代表是主设备发出的，而s代表是从设备发出的，后缀i代表是输入，o代表是输出，其余四个通道信号也是类似。</p><pre><code class="hljs">  //master  output  m_axi_aw_id_o,  output  m_axi_aw_valid_o,  output  m_axi_aw_addr_o,  output  m_axi_aw_len_o,  output  m_axi_aw_size_o,  output  m_axi_aw_burst_o,     input   m_axi_aw_ready_i,  //slave   input   s_axi_aw_id_i,  input   s_axi_aw_valid_i,  input   s_axi_aw_addr_i,  input   s_axi_aw_len_i,  input   s_axi_aw_size_i,  input   s_axi_aw_burst_i,  output  s_axi_aw_reay_o,</code></pre></li><li><h3 id="中间信号"><a href="#中间信号" class="headerlink" title=" 中间信号"></a><b> 中间信号</b></h3><p>  中间信号我们先考虑握手信号和有依赖关系的信号，具体如下</p><pre><code class="hljs">  //handshake  wire  aw_hs   =   axi_aw_ready &amp;  axi_aw_valid;  wire  w_hs    =   axi_w_ready  &amp;  axi_w_valid;  wire  b_hs    =   axi_b_ready  &amp;  axi_b_valid;  wire  ar_hs   =   axi_ar_ready  &amp;  axi_ar_valid;  wire  r_hs    =   axi_r_ready  &amp;  axi_r_valid;  //done  wire  w_done  = w_hs  &amp;   axi_w_last;   wire  r_done  = r_hs  &amp;&amp;  axi_r_last; </code></pre><p>  其中w_done根据官方文档的依赖关系我们知道一次写完成依赖于写数据通道的完成，而代表一次完成写数据的完成又是由w_last信号代替的<br>  &#x2F;&#x2F;未完待续，晚上继续写</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>axi总线学习笔记（一）基本知识介绍</title>
    <link href="/2022/08/17/axi/"/>
    <url>/2022/08/17/axi/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><pre><code class="hljs">本文对AMBA中的AXI总线进行学习和总结并尝试根据一生一芯项目中的要求最终写出总线读写接口，以下是跟着官方文档（An introduction to AMBA AXI 和 AMBA AXI and ACE Protocol Specification）及相关博客边学边写的内容顺寻会比较乱之后有空会再修改，文末会标明参考的博客文章出处，本人还是小小白，学习过程中肯定包含错误，错误之处欢迎指出。</code></pre><span id="more"></span><h2 id="AMBA基本介绍"><a href="#AMBA基本介绍" class="headerlink" title="AMBA基本介绍"></a><b>AMBA基本介绍</b></h2><p>AXI总线协议是AMBA（Advanced Microcontroller Bus Architecture）总线中的一种，AMBA根据官方文档的定义(is an open-standard, on-chipinterconnect specification for the connection and management of functional blocks in system-on-achip (SoC) designs.)是一种将链接和管理外部功能模块和片上系统（soc)的一种接入规范，以下官方文档中的一个soc结构图解释了AMBA总线的应用<br><img src="/.com//img/AXI-learning/AMBA.png"></p><p>AMBA目前已经已经发展到了第五代，包含了APB，AHB,AXI,ACE,CHI，ATB等标准分别应用于不同的需求场景中，其中本次学习的AXI（Advanced eXtensible Interface ）主要是面向高性能，高宽带，低延迟的一个片内总线议。</p><h2 id="AXI基本介绍"><a href="#AXI基本介绍" class="headerlink" title="AXI基本介绍"></a><b>AXI基本介绍</b></h2><p>根据官方文档定义AXI is an interface specification that defines the interface of IP blocks, rather than the interconnect itself(定义翻译过来AXI是一种接口规范，它定义了IP块的接口，而不是互连本身，定义有点绕，后面文档也有进一步解释The AXI protocol is a point-to-point specification, not a bus specification. Therefore,it describes only the signals and timing between interfaces.{AXI协议是一个点对点的规范，而不是一个总线规范。因此它只描述接口之间的信号和时间})，AXI只有两方端口一个是manager（上一代文档里又叫master），一个是subordinate(上一代文档里又叫slave)，AXI有着以下的优点：</p><ul><li><p>因为是直接连接主从双方所以会有最大的带宽，所以适用于高带宽和低延迟的设计</p></li><li><p>不需要复杂的桥接设计</p></li><li><p>向后兼容AHB和APB接口</p></li><li><p>满足多种组件的接口需求</p><p>  以下的官方文档的图展现了axi的应用于SOC系统中，这个图也表现了axi是点对点的连接manager和subordinate，一个manage interface连接一个subordinate interface</p></li></ul><p> <img src="/.com//img/AXI-learning/AXI_interface.png"></p><h2 id="AXI通道基本介绍"><a href="#AXI通道基本介绍" class="headerlink" title="AXI通道基本介绍"></a><b>AXI通道基本介绍</b></h2><p>AXI规范描述了两个接口之间的点对点协议：一个管理器和一个从属接口。下方官方文档图简要显示了每个AXI接口用于通信的五个主要通道通信。</p><p><img src="/.com//img/AXI-learning/AXI_channel.png"></p><p>根据上面的图首先可以分为写操作和读操作</p><h3 id="写操作传输过程"><a href="#写操作传输过程" class="headerlink" title="写操作传输过程"></a><b>写操作传输过程</b></h3><ul><li><h3 id="写地址通道AW-Write-Adress"><a href="#写地址通道AW-Write-Adress" class="headerlink" title="写地址通道AW(Write Adress)"></a>写地址通道AW(Write Adress)</h3></li><li><h3 id="写数据通道W（Write-data"><a href="#写数据通道W（Write-data" class="headerlink" title="写数据通道W（Write data)"></a>写数据通道W（Write data)</h3></li><li><h3 id="写回应通道B（Write-Response"><a href="#写回应通道B（Write-Response" class="headerlink" title="写回应通道B（Write Response)"></a>写回应通道B（Write Response)</h3><img src="/.com//img/AXI-learning/Write_channel.png"></li></ul><h3 id="读操作传输过程"><a href="#读操作传输过程" class="headerlink" title="读操作传输过程"></a><b>读操作传输过程</b></h3><ul><li><h3 id="读地址通道AR-Read-Adress"><a href="#读地址通道AR-Read-Adress" class="headerlink" title="读地址通道AR(Read Adress)"></a>读地址通道AR(Read Adress)</h3></li><li><h3 id="写数据通道R（Read-data"><a href="#写数据通道R（Read-data" class="headerlink" title="写数据通道R（Read data)"></a>写数据通道R（Read data)</h3><img src="/.com//img/AXI-learning/Read_channel.png"></li></ul><p>对于地址通道传输过程中携带了地址及一些控制信息，从上图看出两个地址通道都是由manager传输到subordinate，而对于数据通道对于写数据通道是由manager传输到subordinate而读数据则由subordinate传输到manager，而当写传输完成后由subordinate通过写响应通道传输告知manager本次传输完成。而这种分离的地址和数据通道可以使接口的带宽最大化，同时读和写之间的没有时间关系，意味着读可以同时写</p><ul><li><b>Q1 注意的是为什么要一个写响应通道,而为什么没有读响应通道</b><br>因为每个通道都是单向的，所以需要一个单独的写入响应通道来把响应传回给管理器。然而，不需要一个读响应通道，因为读响应是作为读数据通道的一部分传递的。</li></ul><h2 id="AXI传输过程"><a href="#AXI传输过程" class="headerlink" title="AXI传输过程"></a><b>AXI传输过程</b></h2><ul><li><h2 id="时钟和复位信号-ACLK-amp-ARESETn"><a href="#时钟和复位信号-ACLK-amp-ARESETn" class="headerlink" title="时钟和复位信号(ACLK &amp; ARESETn) "></a><b>时钟和复位信号(ACLK &amp; ARESETn) </b></h2><p>  所有输入信号都在时钟ACLK上升沿被采样，所有输出信号的变化只能在ACLK上升沿后<br>  而复位信号低电平复位，再说明下可以<b>异步复位</b>，不然默认下是在时钟上升沿<b>同步复位</b>复位时接口时，manager的ARVALID,AWVALID,WVALID保持低电平，subordinate的RVALID,BVALID保持低电平，其他根据设计来，<b>最早可以拉高的点在复位后一个周期的上升沿，如下图</b></p><p>  <img src="/.com//img/AXI-learning/ARESETn.png"></p></li><li><h2 id="握手机制（Handshake"><a href="#握手机制（Handshake" class="headerlink" title="握手机制（Handshake)"></a><b>握手机制（Handshake)</b></h2><p>  五个通道都有用到相同的VALID&#x2F;READY的握手信号来进行传输地址，数据和控制信息。这种双向的控制机制意味着主机和从机都可以控制信息在双方之间的流动速度。源产生方产生VALID信号表明目前地址数据和控制信号可用，目的方产生READY信号去表明当前可以接收信息。而当同时VALID和READY同时拉高（VALID &amp; READY）则表示握手成功。<br><br>  <b>注:主从接口之间的输入输出信号间不能有组合路径。</b></p><p>  三种可能的握手过程<br></p><ul><li><h3 id="VALID信号先拉高"><a href="#VALID信号先拉高" class="headerlink" title="VALID信号先拉高"></a><b>VALID信号先拉高<br></b></h3><p>  <img src="/.com//img/AXI-learning/handshake_v_first.png"></p></li><li><h3 id="READY信号先拉高"><a href="#READY信号先拉高" class="headerlink" title="READY信号先拉高"></a><b>READY信号先拉高<br></b></h3><p>  <img src="/.com//img/AXI-learning/handshake_r_first.png"></p></li><li><h3 id="READY和VALID同时拉高"><a href="#READY和VALID同时拉高" class="headerlink" title="READY和VALID同时拉高"></a><b>READY和VALID同时拉高<br></b></h3><p>  <img src="/.com//img/AXI-learning/handshake_r_v.png"></p></li></ul><p>  可以看出不管哪个信号先到都是直到T3两个信号都拉高后的一个周期后的上升沿才开始进行传输如果valid先拉高则是先把数据地址控制信息已经准备好要一直缓存保持数据稳定到传输的时刻（不允许释放或改变），即一旦VALID有效，源端必须等待握手发生，即在保持VALID不变的情况下，等待目的端的READY信号有效。如果先让ready信号拉高则当valid一到则下个周期上升沿就要进行传输，数据只需要保持一个周期的稳定,目的端可以在自身READY信号无效的情况下，等待源端的VALID信号有效，这一条规则和上一条规则必须同时遵守，则可能造成死锁等待，同时，在VALID有效前，即使READY已经有效，也可以再次令READY无效。当两个信号同时拉高，则自然等下个周期的上升沿开始信号传输</p></li><li><h2 id="握手信号（Handshake-signal"><a href="#握手信号（Handshake-signal" class="headerlink" title="握手信号（Handshake signal)"></a><b>握手信号（Handshake signal)</b></h2><p>  <img src="/.com//img/AXI-learning/handshake_signal.png"></p><ul><li><h3 id="写地址通道（AWVALID-AWREADY）"><a href="#写地址通道（AWVALID-AWREADY）" class="headerlink" title="写地址通道（AWVALID AWREADY）"></a>写地址通道（AWVALID AWREADY）</h3><p>  AWVALID<b>仅当输出有效的地址和控制信息时才能拉高</b>,在从设备的AWREADY信号有效后的第一个时钟上升沿，主设备的AWVALID信号必须保持有效.同时AWREADY信号的默认状态可以为高也可以为低电平，规范推荐默认状态为高电平。当该信号为高电平时，意味着从设备一定可以接受任何有效的地址。<br><br>  注：<b> 规范不推荐AWREADY信号默认为低电平是因为这会强制使传输周期拉长到至少两个时钟周期，一个周期用于使能AWVALID信号，另一个周期则用于使能AWREADY信号。</b></p></li><li><h3 id="写数据通道（WVALID-WREADY）"><a href="#写数据通道（WVALID-WREADY）" class="headerlink" title="写数据通道（WVALID WREADY）"></a>写数据通道（WVALID WREADY）</h3><p>  写突发的时候，主机可以仅当写数据有效时使能WVALID，而一样的WVALID必须要保持直到WREADY使能后一个周期，默认WREADY为高使能，但从机可以在一个周期内进行写数据，且主机突发下WLAST信号必须使能。</p></li><li><h3 id="写响应通道（BVALID）"><a href="#写响应通道（BVALID）" class="headerlink" title="写响应通道（BVALID）"></a>写响应通道（BVALID）</h3><p>  从设备输出有效的写响应信号才能驱动BVALID信号，同样的在BREADY信号有效后的第一个周期要上升沿保持有效，BREADY信号默认可以为高电平，但此时主设备必须总能在一个时钟周期内接收写响应。</p></li><li><h3 id="读数据通道-RVALID-RREADY"><a href="#读数据通道-RVALID-RREADY" class="headerlink" title="读数据通道(RVALID RREADY)"></a>读数据通道(RVALID RREADY)</h3><p>  从设备只有在输出有效读数据时才能使能RVALID信号，同时在主设备的RREADY信号有效后的第一个时钟上升沿必须保持有效。<b>即使从设备只有一个读数据源，它也必须在收到数据请求时才令RVALID信号有效。</b></p></li><li><h3 id="读地址通道-ARVALID-AREADY"><a href="#读地址通道-ARVALID-AREADY" class="headerlink" title="读地址通道(ARVALID AREADY)"></a>读地址通道(ARVALID AREADY)</h3><p>  主设备仅当输出有效的地址和控制信息时才能使能ARVALID信号，在从设备的AWREADY信号有效后的第一个时钟上升沿，主设备的ARVALID信号必须保持有效。ARREADY信号的默认状态可以为高也可以为低电平，规范推荐默认状态为高电平。当该信号为高电平时，意味着从设备一定可以接受任何有效的地址.<br>  注：<b>规范不推荐ARREADY信号默认为低电平是因为这会强制使传输周期拉长到至少两个时钟周期，一个周期用于使能ARVALID信号，另一个周期则用于使能ARREADY信号。</b></p></li></ul></li><li><h2 id="通道握手信息依赖关系（为了避免死锁）"><a href="#通道握手信息依赖关系（为了避免死锁）" class="headerlink" title="通道握手信息依赖关系（为了避免死锁）:"></a><b>通道握手信息依赖关系</b>（为了避免死锁）:</h2><ul><li>发送信息的AXI接口的valid信号不能依赖于接收信息的ready信号</li><li>接收信号的AXI接口在其自身的ready信号有效前可以等待对方的valid信号</li></ul></li></ul><h4 id="读传输依赖-Read-transaction-dependencies-："><a href="#读传输依赖-Read-transaction-dependencies-：" class="headerlink" title="读传输依赖(Read transaction dependencies)："></a>读传输依赖(Read transaction dependencies)：</h4><pre><code class="hljs"> - VALID发出方要先使能VALID信号才能开始等待READY信号;而READY发出方·不必等待VALID有效，就可以发出READY信号，也可以等VALID信号发出后再发出，且读数据通道的VALID信号不能保持常态有效，    如下图的依赖关系图，其中单箭头指向的表示不需要在意始端的先后，双向箭头指向的信号表示必须等待始端使能后才能进行使能</code></pre><p> <img src="/.com//img/AXI-learning/depend_r.png" alt="读依赖关系"></p><h4 id="写依赖关系-AXI3（Write-transaction-dependencies"><a href="#写依赖关系-AXI3（Write-transaction-dependencies" class="headerlink" title="写依赖关系-AXI3（Write transaction dependencies):"></a>写依赖关系-<b>AXI3</b>（Write transaction dependencies):</h4><pre><code class="hljs">- 主设备在使能VALID信号后才能等待READY信号的使能- 从设备的READY信号可以等VALID信号使能后再使能也可以先使能等待VALID使能- 从设备必须等WVALID &amp; WREADY才能使能BAVALID信号- 从设备必须等待WLAST有效才能使能BAVLID，写响应必须发送在一次写事务中的最后一次数据传输后- 从设备必须在使能BVALID后使能BREADY</code></pre><p><img src="/.com//img/AXI-learning/depend_w.png" alt="写依赖关系AXI3">            </p><h4 id="写依赖关系-AXI4-x2F-5（Write-transaction-dependencies"><a href="#写依赖关系-AXI4-x2F-5（Write-transaction-dependencies" class="headerlink" title="写依赖关系-AXI4&#x2F;5（Write transaction dependencies):"></a>写依赖关系-<b>AXI4&#x2F;5</b>（Write transaction dependencies):</h4><pre><code class="hljs">根据文档AXI4的写依赖和AXI3中的主设备是完全兼容的，而对于从设备不完全兼容相对于以上的AXI3版依赖，从设备要等待AWVALID,AWREADY,WVALID,WREADY有效后才能使能BAVLID，即AWVALID &amp; AREADY &amp; WVALID &amp; WREADY &amp; WLAST的关系，所以建议尽量使用更严格的AXI4依赖关系具体依赖如下图：</code></pre><p><img src="/.com//img/AXI-learning/AXI4_depend_w.png" alt="写依赖关系AXI4"></p><ul><li><h2 id="一次传输的完整过程"><a href="#一次传输的完整过程" class="headerlink" title="一次传输的完整过程"></a><b>一次传输的完整过程</b></h2><p>  以下通过单数据和多数据的例子介绍写传输过程和读传输过程：<br></p><h3 id="单个数据的读传输过程"><a href="#单个数据的读传输过程" class="headerlink" title=" 单个数据的读传输过程"></a><b> 单个数据的读传输过程</b></h3><ul><li><p>首先是读地址通道进行握手过程<br>  <img src="/.com//img/AXI-learning/handshake_AR.png" alt="读地址握手">  </p><pre><code class="hljs">     主设备在准备好读地址后在第二个时钟周期把读地址信息和ARVALID信号(使能）同时传输给从设备，在下个周期（第三个周期）从设备使能ARREADY表明准备好接收地址信息，最后在下个周期（第四个周期）完成握手</code></pre></li><li><p>然后是读数据通道进行握手过程<br>  <img src="/.com//img/AXI-learning/handshake_R.png" alt="读数据握手"></p><pre><code class="hljs">     在第n个时钟周期，主设备使能RREADY表明在等待接收数据，然后从设备把数据准备好在第n+2个周期时送出数据，在这种单一数据传输时表示整个数据传输完成所以把RLAT使能拉高，同时从机再用RRESP表明这次读传输的成功或失败，最后同时使能RVALID，在下个周期上升沿即第n+3个周期上升沿完成握手</code></pre></li></ul><h3 id="单个数据的写传输过程"><a href="#单个数据的写传输过程" class="headerlink" title=" 单个数据的写传输过程"></a><b> 单个数据的写传输过程</b></h3><ul><li><p>首先是写地址通道进行握手过程<br>  <img src="/.com//img/AXI-learning/handshake_AW.png" alt="写地址握手"></p><pre><code class="hljs">     主设备把写地址准备好并在第二个时钟周期使能AWVALID有效信号，从设备在第三个周期把AWREADY使能表明当前能够接收主设备的地址信息，等到下一个周期时钟上升沿即第四周期上升沿完成握手</code></pre></li><li><p>然后进行写数据通道的握手过程<br>  <img src="/.com//img/AXI-learning/handshake_W.png" alt="写数据握手"></p><pre><code class="hljs">     从设备在第n个时钟周期时使能WREADY后等待写数据WDATA的到来，主设备把数据准备好缓存准备传输并在第n+2个时钟周期使能WVALID，等到第n+3个周期的上升沿达成握手把数据传到从设备</code></pre></li><li><p>最后进行写响应通道的握手过程<br>  <img src="/.com//img/AXI-learning/handshake_B.png" alt="写响应握手"></p><pre><code class="hljs">     当写数据完成时的同时使能BREADY即WLAST使能后的下个上升沿，然后从设备使能BRESP表明当次传输的成功或失败同时使能BVALID，同样是在第n+3个周期的上升沿完成握手</code></pre></li></ul><h3 id="多个数据的读传输过程"><a href="#多个数据的读传输过程" class="headerlink" title=" 多个数据的读传输过程"></a><b> 多个数据的读传输过程</b></h3><ul><li><p>The AXI protocol also allows a read burst of multiple data transfer in the same transaction（AXI协议也允许一个多数据的读突发–不知道翻译的对不对）<br>  <img src="/.com//img/AXI-learning/handshake_mul_r.png" alt="多数据读"></p><pre><code class="hljs">     和单个数据一样也是先通过读地址通道传输单个地址和AVALID控制信号，从图里可以看出读地址通道AR地址传输了三个周期，所以在读数据通道R里一共从从设备传输了三个数据到主设备，到了读数据通道R时，当等到RVALID和RREADY握手时从设备把数据传输到主设备，同时拉高RRESP表示传输的成功与否，注意的是这里的RLAST信号是在第三个数据传输时才拉高即和之前的依赖关系说的一样RLAST是表示最后一个数据传输完成的信号代表本次所有传输完成。     注：读传输过程中的RRESP用来表明读操作的状态，于写传输过程中的写响应通道的功能有类似，同时当在一次传输中存在错误时也要继续进行完完整的传输，不存在突出中途终止的情况。</code></pre></li></ul><h3 id="多个数据的写传输过程"><a href="#多个数据的写传输过程" class="headerlink" title=" 多个数据的写传输过程"></a><b> 多个数据的写传输过程</b></h3><ul><li><p>首先是写地址通道进行握手过程<br>  <img src="/.com//img/AXI-learning/handshake_mul_w.png" alt="多数据写"></p><pre><code class="hljs">     和上面读的传输过程类似，因为在AW过程中有三个周期的地址传输，所以W通道总共传输了三个数据，同样也存在一个WLAST信号来表示整个传输过程的完成，即可以通过WLAST信号来监视传输过程的状态，当所有的数据都被从设备接收完成后，从设备会使能BRESP信号，一个单一的BRESP代表了一次完整的写突发过程     注：如果从设备决定任何传输的数据错误，必须等到完整的突发传输完成才能发出信号告知主设备有错误。</code></pre></li></ul></li></ul><h2 id="通道信号"><a href="#通道信号" class="headerlink" title="通道信号"></a><b>通道信号</b></h2><h3 id="下面是官方文档给出的主要的AXI通道的信号"><a href="#下面是官方文档给出的主要的AXI通道的信号" class="headerlink" title="下面是官方文档给出的主要的AXI通道的信号"></a><b>下面是官方文档给出的主要的AXI通道的信号</b></h3><ul><li><p><b>写地址通道信号</b></p><p>  <img src="/.com//img/AXI-learning/AW_sig.png" alt="写地址通道信号"></p></li><li><p><b>写数据通道信号</b></p><p>  <img src="/.com//img/AXI-learning/W_sig.png" alt="写数据通道信号"></p></li><li><p><b>写响应通道信号</b></p><p>  <img src="/.com//img/AXI-learning/B_sig.png" alt="写响应通道信号"></p></li><li><p><b>读地址通道信号</b></p><p>  <img src="/.com//img/AXI-learning/AR_sig.png" alt="读地址通道信号"><br>  <img src="/.com//img/AXI-learning/AR_sig2.png"></p></li><li><p><b>读数据通道信号</b></p><p><img src="/.com//img/AXI-learning/R_sig.png" alt="读数据通道"></p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><b>小结</b></h2><pre><code class="hljs">主要跟着文档学习了关系AXI总线协议的基本知识，五个传输通道即对应的重要信号和传输过程，下一个总结将尝试独自写AXI读写过程的RTL代码，并根据“一生一芯“项目的要求完成相应部分</code></pre><h3 id="日常推歌"><a href="#日常推歌" class="headerlink" title="日常推歌"></a>日常推歌</h3><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="550" height="86" src="//music.163.com/outchain/player?type=2&id=1876179147&auto=1&height=66"></iframe>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>first blog</title>
    <link href="/2022/07/25/post/"/>
    <url>/2022/07/25/post/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这是个兼容作为歌单和简历及废话的小破博客</p><span id="more"></span><h1 id="第一篇博客发个疯"><a href="#第一篇博客发个疯" class="headerlink" title="第一篇博客发个疯"></a>第一篇博客发个疯</h1><p>立个flag，一个月至少更新一篇博客（手动狗头）</p><h3 id="放个歌单激励一下自己"><a href="#放个歌单激励一下自己" class="headerlink" title="放个歌单激励一下自己"></a>放个歌单激励一下自己</h3><script>console.error("Error: [hexo-tag-aplayer] Unrecognized tag argument(2): https://link.zhihu.com/?target=http%3A//home.ustc.edu.cn/~mmmwhy/%25d6%25dc%25bd%25dc%25c2%25d7%2520-%2520%25cb%25fd%25b5%25c4%25bd%25de%25c3%25ab.mp3");</script>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>废话</tag>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
