<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ic-协议系列(1)</title>
    <link href="/2022/11/17/ic-base/"/>
    <url>/2022/11/17/ic-base/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
    
    
    <categories>
      
      <category>ic</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码系列</tag>
      
      <tag>ic基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言指针学习（入门版）</title>
    <link href="/2022/11/15/pointer/"/>
    <url>/2022/11/15/pointer/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p> C语言指针知识学习。本人菜鸡有讲的不明白或错的请批评指正！</p><span id="more"></span><h3 id="指针定义"><a href="#指针定义" class="headerlink" title="指针定义"></a>指针定义</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">int</span> a=<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> *p          <span class="hljs-comment">//定义分配了空间</span><br>p = &amp;a;         <span class="hljs-comment">//赋值</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p = %d\n&quot;</span>,p);   <span class="hljs-comment">//输出的是a的地址</span><br><span class="hljs-type">int</span> *p = &amp;a;    <span class="hljs-comment">//定义和赋值一起</span><br></code></pre></td></tr></table></figure><p>这里是先定义了一个<strong>整型的指针类型</strong>的变量p,p是变量名，<strong>p的值（或者说叫p存放的内容）是a的地址</strong>,p的大小也是int类型的大小。</p><blockquote><p>对计算机的详细存储过程：</p><ol><li>先给a分配4字节大小，然后把5这个值存进去分配的内存空间里，</li><li>然后给p分配4字节大小的空间，取得a的地址后放入分配给p的地址里,<strong>这里的地址也会转换为二进制存存入按顺序存入分配的四字节</strong></li><li>所以直接打印p，则打印的实际对应的是a的地址，<br><strong>即int*存放的是int数据类型大小的类型的地址</strong></li></ol></blockquote><p>再往下定义一个</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">int</span> **s;<br><span class="hljs-attribute">s</span> = &amp;p;<br></code></pre></td></tr></table></figure><p>根据上面的说明这里的变量是s(变量名)，数据类型为int **, 根据赋值我们可以知道s分配的内存空间里存的值是p的地址</p><blockquote><p>总结一下<br>*<em>s放的是p的地址，</em>s里可以看成放的是p地址空间存放的地址，即a的地址（根据上述的p &#x3D; &amp;a;) 即*p &#x3D; &amp;a;<br>则 *<em>s可以看成</em>（&amp;a),a地址存放的值，即 **s &#x3D; a; </p></blockquote><h3 id="指针操作"><a href="#指针操作" class="headerlink" title="指针操作"></a>指针操作</h3><ol><li>*操作-&gt;取值操作</li><li>&amp;操作-&gt;取地址<br> <em>p–&gt;</em>(p),p的值作为内存地址这里叫a，<em>p就说从a这个地址中取出里面存放的数据<br> *<em>p–&gt;</em>(<em>p)–&gt;</em>(*)(p),先取</em>p的值作为地址b，继续从b接着取一次值就是<blockquote><p><strong>不管什么操作左右两边的数据类型得一致，不然不应该进行操作</strong></p></blockquote></li></ol><p>简单的小例子<br>        <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">char</span> *<span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;hello world&quot;</span>;<br>printf(<span class="hljs-string">&quot;%c\n&quot;</span>,*<span class="hljs-built_in">str</span>);<br></code></pre></td></tr></table></figure></p><blockquote><p><strong>这里需要记住的是<em>操作前面的数据类型对应的是最后取值能够存放的对应内存空间，比如这里是char，所以实际上</em>str的值应该是’h’,而不是”hello world”</strong></p></blockquote><p> <strong>参考文章：</strong><br> <a href="https://zhuanlan.zhihu.com/p/101934152">C语言重点——指针篇（一篇让你完全搞懂指针） - 一直流浪的文章 - 知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
      <category>C语言基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言常见库函数实现(1)</title>
    <link href="/2022/11/15/libc/"/>
    <url>/2022/11/15/libc/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文将尝试实现string库里的几个常见的库函数</p><span id="more"></span><h1 id="字符类处理函数-string-h"><a href="#字符类处理函数-string-h" class="headerlink" title="字符类处理函数(string.h)"></a>字符类处理函数(string.h)</h1><h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h3><blockquote><p><strong>手册定义:</strong> size_t strlen(const char *s)<br><strong>描述：</strong>calculate the length of a string pointed to by s,excluding the terminating null byte (‘\0’).<br><strong>返回值：</strong>return the number of bytes in the string pointed to by s.</p></blockquote><p>思路：指针操作让其从字符串起始开始移动到最后的’\0’，同时记数，实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">strlen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *tmp = s;<br><span class="hljs-type">size_t</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(*tmp != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>n++;<br>tmp++;<br>&#125;<br><span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h3><blockquote><p><strong>手册定义:</strong> char *strcpy(char *dest, const char *src)<br><strong>描述:</strong>  copy the string pointed to by src, including the terminating null byte (‘\0’), to the buffer pointed to by dest. the string may not overlap,and the destination string dest must be large enough to receive the copy. <strong>Bewarwe of buffer overruns</strong><br><strong>返回值</strong> return a pointer to dest</p></blockquote><p>分析：复制字符串到新字符串包括空字符，返回值是个指针，且要保证目的字符串内存足够大去接收复制的字符串<br>思路：基于上一个实现的strlen函数的话，很容易想到可以定义一个指针从源字符串首字符开始赋值给新字符串，赋值个数为strlen(dest)+1(要加上空字符)，实现代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">char</span> *strcpy(<span class="hljs-built_in">char</span> *dest, const <span class="hljs-built_in">char</span> *src)&#123;<br>int <span class="hljs-built_in">len</span> = strlen(src);<br><span class="hljs-built_in">char</span> *tmp = dest;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">len</span><span class="hljs-comment">--)&#123;</span><br>tmp[<span class="hljs-built_in">len</span>] = src[<span class="hljs-built_in">len</span>];<br>&#125;<br><span class="hljs-keyword">return</span> dest;<br><br></code></pre></td></tr></table></figure><h3 id="strncpy"><a href="#strncpy" class="headerlink" title="strncpy"></a>strncpy</h3><blockquote><p><strong>手册定义：</strong> char *strncpy(char *dest, const char *src, size_t n)<br><strong>描述：</strong> if there is no null byte among the first n byte of src, the string placed in dest will not be null-terminated,if the length of src less than n, strncpy write the null byte to dest ensure n byte are written.</p></blockquote><p>分析：就是strcpy函数多了给n参数，可以选择复制的最大字节个数（n byte)，根据描述这里可以分为当源字符串小于nbyte或者大于nbyte的情况，小于的时候需要补’\0’，大于的话就直接复制过去nbyte相当于strcpy里确定的strlen值，而且源字符串里如果有空字符也要对应复制，所以可以归并成一种情况，实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">strncpy</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src, <span class="hljs-type">size_t</span> n)</span></span>&#123;<br><span class="hljs-type">size_t</span> k;<br><span class="hljs-type">char</span> *tmp = dest;<br><span class="hljs-keyword">for</span>( k = <span class="hljs-number">0</span>; k&lt;n &amp;&amp; src[k] != <span class="hljs-string">&#x27;\0&#x27;</span>; k++)&#123;<br>tmp[k] = src[k];<br>&#125;<br><span class="hljs-keyword">for</span> (; k &lt; n; k++)&#123;<br>tmp[k] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> dest;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="strcat"><a href="#strcat" class="headerlink" title="strcat"></a>strcat</h3><blockquote><p><strong>手册定义</strong> char *strcat(char *dest, const char *src);<br><strong>描述</strong> appends the src string to the dest string, overwriting the terminating null byte ‘\0’ at the end of dest,and add the null byte.<br><strong>返回值</strong> return a pointer to the resulting string dest</p></blockquote><p>分析：从目的字符串最后开始连接一个字符串，要把目的字符串的空字符覆盖掉，所以应该先找到目的字符串长度，然后再进行拼接，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">strcat</span><span class="hljs-params">(<span class="hljs-type">char</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src)</span></span>&#123;<br><span class="hljs-type">size_t</span> len = <span class="hljs-built_in">strlen</span>(dest);<br><span class="hljs-type">char</span> *tmp = dest+len;<br><span class="hljs-keyword">while</span>(*src != <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>*tmp = *src;<br>tmp++;<br>src++;<br>&#125;<br><span class="hljs-keyword">return</span> dest;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h3><blockquote><p><strong>手册定义</strong> int strcmp(const char* s1, const char* s2);<br><strong>描述</strong> compare the two string s1 and s2, the comparision is done using unsigned characters;<br><strong>返回值</strong> 0 –&gt; s1 &#x3D;&#x3D; s2; negative –&gt; s1 less s2; positive s1 &gt; s2;</p></blockquote><p>分析：就是比较两个字符串，一般常用于判断字符串是否相等，所以思路就可以进行指针操作逐一字符比较注意要进行的是无符号的比较，做减法得出返回值，实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strcmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s1,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s2)</span></span>&#123;<br><span class="hljs-type">int</span> ret = *(<span class="hljs-type">unsigned</span> *)s1 - *(<span class="hljs-type">unsigned</span> *)s2;<br><span class="hljs-keyword">while</span> (!ret &amp;&amp; *s1)&#123;<br>s1++;<br>s2++;<br>ret = *(<span class="hljs-type">unsigned</span> *)s1 - *(<span class="hljs-type">unsigned</span> *)s2;<br>&#125;<br><span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="strncmp"><a href="#strncmp" class="headerlink" title="strncmp"></a>strncmp</h3><blockquote><p><strong>手册定义</strong> int strcmp(const char* s1, const char* s2,size_t n);<br><strong>描述</strong> similiar strcmp,but compare the first n bytes of s1 and s2<br><strong>返回值</strong> 0 –&gt; s1 &#x3D;&#x3D; s2; negative –&gt; s1 less s2; positive s1 &gt; s2;</p></blockquote><p>分析：和strcmp类似，但是因为这里只比较前n位，所以得先分出那个字符串长度长，把长的作为比较基准（相等其实没关系了），实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strncmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s1, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *s2,<span class="hljs-type">size_t</span> n)</span> </span>&#123;<br><span class="hljs-type">int</span> ret = *(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)s1 - *(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)s2;<br><span class="hljs-type">int</span> l =  <span class="hljs-built_in">strlen</span>(s1) - <span class="hljs-built_in">strlen</span>(s2);<br><span class="hljs-keyword">if</span>(l &gt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">while</span>(!ret &amp;&amp; n-- != <span class="hljs-number">0</span> &amp;&amp; *s1)&#123;<br>s1++;<br>s2++;<br>ret = *(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)s1 - *(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)s2;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">while</span>(!ret &amp;&amp; n-- != <span class="hljs-number">0</span> &amp;&amp; *s2)&#123;<br>s1++;<br>s2++;<br>ret = *(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)s1 - *(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)s2;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret &lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h3><blockquote><p><strong>手册定义：</strong> void *(void *s, int c, size_t n );<br><strong>描述：</strong>the function fill the first n bytes of the memory area pointed to by s with the constant byte c<br><strong>返回值：</strong> return a pointer to the memory areas</p></blockquote><p>分析：很好理解根据定义。把一块内存里全部填满指定的值(一般用于开辟内存的初始化)。那就直接进行赋值就行，实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-type">void</span> *s, <span class="hljs-type">int</span> c, <span class="hljs-type">size_t</span> n)</span> </span>&#123;<br><span class="hljs-type">char</span> *tmp = s;<br><span class="hljs-keyword">while</span>(n--)&#123;<br>*tmp = c;<br>tmp++;<br>&#125;<br><span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h3><blockquote><p><strong>手册定义：</strong> void *memcpy(void <em>dest, const void</em>src, size_t n);<br><strong>描述：</strong> the function copy n bytes from memory area src to the memory area dest, the memory must not overlap<br><strong>返回值：</strong> return a pointer to dest</p></blockquote><p>分析：根据描述赋值一个内存空间到另一个内存空间中，本质就是把源空间内存里的存的数据复制过去，那只要取指针去指向目的空间，通过指针赋值把值取到目的空间即可，实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span> *dest, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> n)</span></span>&#123;<br><span class="hljs-type">char</span> *tmp = dest;<br><span class="hljs-keyword">while</span>(n--) &#123;<br>*tmp = *(<span class="hljs-type">char</span> *)src;<br>src++;<br>tmp++;<br>&#125;<br><span class="hljs-keyword">return</span> dest;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="memcmp"><a href="#memcmp" class="headerlink" title="memcmp"></a>memcmp</h3><blockquote><p><strong>手册定义：</strong> int memcmp(const void *s1, const void *s2, size_t n);<br><strong>描述：</strong> the function compare the first n byte(each interpreted as unsigned char) of the memory area s1 and s2<br><strong>返回值：</strong>n &#x3D; 0,return zero, s1 less than s2 return negative, s1 match s2 return zero, s1 greater than s2 return positive</p></blockquote><p>分析：根据手册本质是比较内存空间的数据大小，和strcmp类似，但是是不考虑空字符的影响，直接比较nbytes，实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">memcmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *s1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *s2, <span class="hljs-type">size_t</span> n)</span> </span>&#123;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(!ret &amp;&amp; n--) &#123;<br>ret = *(<span class="hljs-type">char</span> *)s1 - *(<span class="hljs-type">char</span> *)s2;<br>s1++;<br>s2++;<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="memmove（本质也是内存复制而不是移动）"><a href="#memmove（本质也是内存复制而不是移动）" class="headerlink" title="memmove（本质也是内存复制而不是移动）"></a>memmove（本质也是内存复制而不是移动）</h3><blockquote><p><strong>手册定义：</strong><br><strong>描述：</strong>the fuction copies n bytes from memory src to memory area dest. the memory areas may overlap<br><strong>返回值：</strong>return a pointer to dest</p></blockquote><p>分析：和memcpy类似，但是这里强调源内存空间和目的内存空间是可以重叠的！在不重叠的情况下其实和memcpy一样，但是在重叠的情况下有可能出现越界，所以应该分两种情况，一种源内存空间地址比目的内存空间地址高，则顺序复制，反之逆序复制,这里要注意代码实现是是一位一位复制而调用时可能不是char型的内存空间.具体代码实现如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">void</span> *memmove(<span class="hljs-type">void</span> *dest, const <span class="hljs-type">void</span> *src, size_t n) &#123;<br><span class="hljs-keyword">if</span>(dest &lt; src) &#123;<br><span class="hljs-type">char</span> *p = (<span class="hljs-type">char</span> *)dest;<br><span class="hljs-type">char</span> *q = (<span class="hljs-type">char</span> *)src;<br><span class="hljs-keyword">while</span>(n<span class="hljs-comment">--)&#123;</span><br>*p++ = *q++;<br><br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">char</span> *p = (<span class="hljs-type">char</span> *)dest+n;<br><span class="hljs-type">char</span> *q = (<span class="hljs-type">char</span> *)src+n;<br><span class="hljs-keyword">while</span>(n<span class="hljs-comment">--) &#123;</span><br>*<span class="hljs-comment">--p = *--q;</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dest;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="以上所有实现代码仅进行了简单的测试，仅供参考，欢迎大佬们指正！"><a href="#以上所有实现代码仅进行了简单的测试，仅供参考，欢迎大佬们指正！" class="headerlink" title="以上所有实现代码仅进行了简单的测试，仅供参考，欢迎大佬们指正！"></a><strong>以上所有实现代码仅进行了简单的测试，仅供参考，欢迎大佬们指正！</strong></h4>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
      <category>代码系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>代码系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PA2笔记</title>
    <link href="/2022/11/13/pa2/"/>
    <url>/2022/11/13/pa2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>PA2学习笔记</p><span id="more"></span><h1 id="PA2-简单复杂的机器-amp-RTFM"><a href="#PA2-简单复杂的机器-amp-RTFM" class="headerlink" title="PA2-简单复杂的机器&amp;RTFM"></a>PA2-简单复杂的机器&amp;RTFM</h1><h2 id="pa2-1-不停的计算机"><a href="#pa2-1-不停的计算机" class="headerlink" title="pa2.1-不停的计算机"></a>pa2.1-不停的计算机</h2><p>再次强化计算机是个状态机   取指-&gt;执行指令-&gt;更新pc</p><h3 id="Q1-理解YEMU如何执行"><a href="#Q1-理解YEMU如何执行" class="headerlink" title="Q1. 理解YEMU如何执行"></a>Q1. 理解YEMU如何执行</h3><ol><li><p>位域结构</p><p> struct {<br>  uint8_t rs : 2, rt : 2, op : 4;<br> } rtype;</p></li></ol><p>所谓“位域”是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 YUMU这里的把rtype的一字节分为多个位域，可以单独访问如rtype.rs表示该字节的低两位<br>有两个注意的点<br><strong>1. 一个位域必须存储在同一个字节中，不能跨两个字节。如一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。</strong><br><strong>2. 由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进位</strong></p><pre><code class="hljs">    struct   bs      &#123;      unsigned   a:4      unsigned   :0   /*空域*/      unsigned   b:4   /*从下一单元开始存放*/      unsigned   c:4      &#125; </code></pre><ol start="2"><li>联合体</li></ol><p>联合成员则共享同一个内存位置。也就是说，联合中的所有成员都是从相同的内存地址开始,实际大小是最大数据类型的倍数;</p><pre><code class="hljs">union Data &#123;int i; double x;string str;&#125;</code></pre><p>所以YEMU是每执行一条指令，先定义了一条指令的联合体分配内存，然后从对应的pc内存里取出指令，根据该条指令的类型的前四位进行指令类型译码，然后根据对应类型的执行，然后使pc指向下一条指令。其中DECODE_R&#x2F;DECODE_M是对于寄存器和访存的宏函数，用于寄存器和内存的读.</p><h3 id="Q2-实现指令"><a href="#Q2-实现指令" class="headerlink" title="Q2. 实现指令"></a>Q2. 实现指令</h3><h4 id="API了解（RISCV64"><a href="#API了解（RISCV64" class="headerlink" title="API了解（RISCV64)"></a>API了解（RISCV64)</h4><ol><li>word_t -&gt; uint64_t</li><li>sword_t-&gt; int64_t</li><li>char *FMT_WORD -&gt; %0x%016lx”</li><li>word_t RESET_VECTOR -&gt; pc初始</li><li>CPU_state{wort_t pc} -&gt;已经定义一个cpu</li><li>ISADecodeInfo-&gt;isa译码结构体</li><li>Decode 译码信息 pc , dnpc, snpc , ISADecode, </li><li>int isa_mmu_check(vaddr_t vaddr, int len, int type); 检查当前系统状态下对内存区间为[vaddr, vaddr + len), 类型为type的访问是否需要经过地址转换. </li><li>paddr_t isa_mmu_translate(vaddr_t vaddr, int len, int type); 对内存区间为[vaddr, vaddr + len), 类型为type的内存访问进行地址转换.</li><li>vaddr_t isa_raise_intr(word_t NO, vaddr_t epc); 抛出一个号码为NO的异常, 其中epc为触发异常的指令PC, 返回异常处理的出口地址.</li><li>word_t isa_query_intr(); 查询当前是否有未处理的中断, 若有则返回中断号码, 否则返回INTR_EMPTY</li></ol><h4 id="一些宏函数"><a href="#一些宏函数" class="headerlink" title="一些宏函数"></a>一些宏函数</h4><ol><li>concct -&gt; 连接两个参数 如 concat(x,y) &#x3D;&#x3D; xy;</li><li>INSTPAT -&gt; </li><li>INSTPAT_INST -&gt;获得指令</li><li>INSTPAT_MATCH指匹配</li><li>decode_operand-&gt;译码</li></ol><h4 id="nemu一条指令的执行"><a href="#nemu一条指令的执行" class="headerlink" title="nemu一条指令的执行"></a>nemu一条指令的执行</h4><ol><li>取指 <ol><li>入口：exec_once()-&gt;isa_exec_once(Decode *s)</li><li>操作：inst_fetch(vaddr_t pc,int len)-&gt;vaddr_ifetch(addr,len)-&gt;paddr_read()-&gt;pmem_read()-&gt;host_read();</li><li>s-&gt;snpc +&#x3D; 4;</li></ol></li><li>译码<ol><li>入口：decode_exec(s);</li><li>操作：调用宏函数模式匹配</li></ol></li><li>执行<ol><li>译码后的执行函数进行指令执行</li></ol></li><li>更新pc<ol><li>s-&gt;pc &#x3D; s-&gt;dnpc;</li><li>s-&gt;dnpc(动态) s-&gt;snpc(静态)</li></ol></li></ol><h4 id="实现指令"><a href="#实现指令" class="headerlink" title="实现指令"></a>实现指令</h4><ol><li>入口：inst.c</li><li>宏R()寄存器，Mr,Mw,访存 ，src1R()取寄存器值一根据指令集设计，BITS()-&gt;[n:m], SEXT()-&gt;有符号扩展，</li><li>值得注意的是J型指令的立即数，因为要扩展所以可以先分别把分开的位先扩展移位后进行按位或运算，有符号比较的时候可以先把变量强制进行有符号转换，跳转指令是动态的所以注意要变得pc应该是什么。</li></ol><h2 id="pa2-2-运行时环境-amp-基础设施"><a href="#pa2-2-运行时环境-amp-基础设施" class="headerlink" title="pa2.2-运行时环境&amp;基础设施"></a>pa2.2-运行时环境&amp;基础设施</h2><h3 id="运行时环境AM"><a href="#运行时环境AM" class="headerlink" title="运行时环境AM"></a>运行时环境AM</h3><h4 id="最简单的运行时环境"><a href="#最简单的运行时环境" class="headerlink" title="最简单的运行时环境"></a>最简单的运行时环境</h4><p>有内存, 有结束运行的方式, 加上实现正确的指令。nemu里pmem物理内存， 结束方式 nemu_trap-&gt;NEMUTRAP-&gt;改变nemu_state使其停下来,isa;</p><h4 id="将运行时环境封装成库函数"><a href="#将运行时环境封装成库函数" class="headerlink" title="将运行时环境封装成库函数"></a>将运行时环境封装成库函数</h4><p>行时环境的一种普遍的存在方式: 库. 通过库, 运行程序所需要的公共要素被抽象成API, 不同的架构只需要实现这些API。</p><h4 id="AM入门"><a href="#AM入门" class="headerlink" title="AM入门"></a>AM入门</h4><pre><code class="hljs">AM = TRM + IOE + CTE + VME + MPE</code></pre><ol><li><p><strong>TRM</strong><br>putch()&#x2F;&#x2F;输出<br>halt()&#x2F;&#x2F;结束-&gt; nemu_trap()-&gt;asm volatike(内联汇编)-&gt;ebreak;<br>_trm_init()&#x2F;&#x2F;初始化<br>Area heap;&#x2F;&#x2F;堆区</p></li><li><p><strong>Q1.通过批处理模式运行NEMU</strong><br>肯定是有个开关的-&gt;如果是通过参数控制肯定有留下读取参数接口-&gt;init_monitor()-&gt;parse_args()-&gt;batch;<br>所以找到对应的编译script-&gt;nemu-&gt;native.mk-&gt;运行参数要加b</p></li><li><p><strong>Q2.常用的C库函数</strong></p><a href="/2022/11/15/libc/" title="C语言库函数实现(1)">C语言库函数实现(1)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>ysyx</category>
      
      <category>PA系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ysyx</tag>
      
      <tag>pa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown简单语法</title>
    <link href="/2022/11/13/hexo/"/>
    <url>/2022/11/13/hexo/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p> Markdown 语法的目标是：成为一种适用于网络的书写语言。 因此，Markdown是兼容Html，HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。写一个Markdown文档，可以将直接使用Markdown语法和Html的标签混合进行使用，因为最后都会转换成Html，但要注意的是，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。</p><h2 id="常用基本语法"><a href="#常用基本语法" class="headerlink" title="常用基本语法"></a>常用基本语法</h2><p> 只总结了一些觉得自己常用的上的，不考虑美观</p><pre><code class="hljs">1.标题：常用类ATX形式行首插入1到6个#对应与1到6阶标题，注#后面要有一个空格  2.字体：Markdown 使用星号（*）和底线（_）作为标记强调字词的符号，你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。      3.分割线：可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。     4.引用： 在引用的文字前加 &gt; 即可。5.列表： Markdown 支持有序列表和无序列表。无序列表使用星号、加号或是减号作为列表标记。有序列表则使用数字接着一个英文句点作为标记。列表可以嵌套，上一级和下一级之间敲三个空格即可6.代码：Markdown中加入代码块有两种方式： 第一种，只要简单地缩进 4 个空格或是 1 个制表符就可以，第二种单行代码：代码之间分别用一个反引号包起来即可；</code></pre><h3 id="效果例子"><a href="#效果例子" class="headerlink" title="效果例子"></a>效果例子</h3><ol><li><p>###空格head</p><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3></li><li><p><strong>粗体</strong>（字两边各两个*）</p></li><li><p>三个星</p><hr></li><li><p>引用，开头有个&gt;符号</p><blockquote><p>引用</p></blockquote></li><li><p>列表(无序)</p><ul><li>一 - 二</li></ul></li><li><p>代码块<br><code>#include ....</code></p></li></ol><h2 id="hexo常见命令"><a href="#hexo常见命令" class="headerlink" title="hexo常见命令"></a>hexo常见命令</h2><pre><code class="hljs">hexo g  //产生htmlhexo c  //清除hexo s  //本地部署hexo d  //部署hexo n &lt;title&gt; //创建新文章</code></pre><h3 id="文章内常用表情"><a href="#文章内常用表情" class="headerlink" title="文章内常用表情"></a>文章内常用表情</h3><pre><code class="hljs">categories：- 类别名字tag:标签名字（可多个）date:日期时间title:标题</code></pre>]]></content>
    
    
    <categories>
      
      <category>hexo博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客开启</title>
    <link href="/2022/07/25/post/"/>
    <url>/2022/07/25/post/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote></blockquote><span id="more"></span><h1 id="第一篇博客发个疯"><a href="#第一篇博客发个疯" class="headerlink" title="第一篇博客发个疯"></a>第一篇博客发个疯</h1><p>每天都要记录下，算是监督自己把</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>废话</tag>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
